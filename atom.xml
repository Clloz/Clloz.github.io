<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://clloz.github.io/</id>
    <title>Clloz - 素直になれない</title>
    <updated>2020-10-04T11:02:15.272Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://clloz.github.io/"/>
    <link rel="self" href="https://clloz.github.io/atom.xml"/>
    <subtitle>博观而约取，厚积而薄发&lt;br&gt;
本网站为&lt;a href=&quot;https://www.clloz.com&quot; target=&quot;_blank&quot;&gt;个人博客&lt;/a&gt;的备份</subtitle>
    <logo>https://clloz.github.io/images/avatar.png</logo>
    <icon>https://clloz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Clloz - 素直になれない</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript 中的按位操作符]]></title>
        <id>https://clloz.github.io/post/bitwise-operator/</id>
        <link href="https://clloz.github.io/post/bitwise-operator/">
        </link>
        <updated>2020-10-04T11:01:13.000Z</updated>
        <content type="html"><![CDATA[<p id="my-logo"><a href="https://www.clloz.com">Clloz</a></p>
<p>本文首发于个人博客<a href="https://www.clloz.com">clloz.com</a></p>
<h3 id="前言">前言</h3>
<p><code>JavaScript</code> 提供了多种按位操作符，由于不是很了解，我使用频率很低。不过经常看到别人的代码中利用按位操作符简化代码，在一些场景下能够更有效率。本文记录学习按位操作符的笔记。</p>
<h3 id="按位操作符">按位操作符</h3>
<p><code>JavaScript</code> 中的按位操作符见下表：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>按位与（ <code>AND</code>）</td>
<td><code>a &amp; b</code></td>
<td>对于每一个比特位，只有两个操作数相应的比特位都是 <code>1</code> 时，结果才为 <code>1</code>，否则为 <code>0</code>。</td>
</tr>
<tr>
<td>按位或（<code>OR</code>）</td>
<td><code>a | b</code></td>
<td>对于每一个比特位，当两个操作数相应的比特位至少有一个 <code>1</code> 时，结果为 <code>1</code>，否则为 <code>0</code>。</td>
</tr>
<tr>
<td>按位异或（<code>XOR</code>）</td>
<td><code>a ^</code></td>
<td>对于每一个比特位，当两个操作数相应的比特位有且只有一个 <code>1</code> 时，结果为 <code>1</code>，否则为 <code>0</code>。</td>
</tr>
<tr>
<td>按位非（<code>NOT</code>）</td>
<td><code>~ a</code></td>
<td>反转操作数的比特位，即 <code>0</code> 变成 <code>1</code>，<code>1</code> 变成 <code>0</code>。</td>
</tr>
<tr>
<td>左移（<code>Left shift</code>）</td>
<td><code>a &lt;&lt; b</code></td>
<td>将 <code>a</code> 的二进制形式向左移 <code>b (&lt; 32)</code> 比特位，右边用 <code>0</code> 填充。</td>
</tr>
<tr>
<td>有符号右移</td>
<td><code>a &gt;&gt; b</code></td>
<td>将 <code>a</code> 的二进制表示向右移 <code>b (&lt; 32)</code> 位，丢弃被移出的位。</td>
</tr>
<tr>
<td>无符号右移</td>
<td><code>a &gt;&gt;&gt; b</code></td>
<td>将 <code>a</code> 的二进制表示向右移 <code>b (&lt; 32)</code> 位，丢弃被移出的位，并使用 <code>0</code> 在左侧填充。</td>
</tr>
</tbody>
</table>
<p>所有的按位操作符的操作数都会被转成补码形式的有符号 <code>32</code> 位二进制整数。关于补码的知识，可以参考我的另一片文章<a href="https://www.clloz.com/programming/assorted/2019/06/05/true-form-ones-complement-twos-complement/" title="原码，反码和补码">原码，反码和补码</a>。如果操作数是一个非数字，我们需要注意 <code>JavaScript</code> 会将它转化为什么：</p>
<pre><code class="language-javascript">Number(null) //0
Number(undefined) //NaN
Number([]) //0
Number([1,2,3]) //NaN
Number(true) //1
Number(false) //0
Number('123') //123
Number('abc') //NaN
Number('') //0
Number(Symbol(123)) //Uncaught TypeError: Cannot convert a Symbol value to a number
</code></pre>
<h4 id="按位逻辑操作符">按位逻辑操作符</h4>
<p>按位逻辑操作符（按位与 <code>&amp;</code>， 按位或 <code>|</code>，按位异或 <code>^</code>，按位非 <code>~</code>）的规则：操作数被转换成 <code>32</code> 位二进制整数，超过 <code>32</code> 位的数字会被丢弃。第一个操作数的每个比特位与第二个操作数的相应比特位匹配（匹配规则见下方无序列表）：第一位对应第一位，第二位对应第二位，以此类推。位运算符应用到每对比特位，结果是新的比特值。</p>
<p>位匹配规则：</p>
<ul>
<li>按位与 <code>&amp;</code>：对每对比特位执行与（<code>AND</code>）操作。只有 <code>a</code> 和 <code>b</code> 都是 <code>1</code> 时，<code>a AND b</code> 才是 <code>1</code>。将任一数值 <code>x</code> 与 <code>0</code> 执行按位与操作，其结果都为 <code>0</code>。将任一数值 <code>x</code> 与 <code>-1</code> 执行按位与操作，其结果都为 <code>x</code>。</li>
<li>按位或 <code>|</code>：对每一对比特位执行或（<code>OR</code>）操作。如果 <code>a</code> 或 <code>b</code> 为 <code>1</code>，则 <code>a OR b</code> 结果为 <code>1</code>。将任一数值 <code>x</code> 与 <code>0</code> 进行按位或操作，其结果都是 <code>x</code>。将任一数值 <code>x</code> 与 <code>-1</code> 进行按位或操作，其结果都为 <code>-1</code>。</li>
<li>按位异或 <code>^</code>: 对每一对比特位执行异或（<code>XOR</code>）操作。当 <code>a</code> 和 <code>b</code> 不相同时，<code>a XOR b</code> 的结果为 <code>1</code>。将任一数值 <code>x</code> 与 <code>0</code> 进行异或操作，其结果为 <code>x</code>。将任一数值 <code>x</code> 与 <code>-1</code> 进行异或操作，其结果为 <code>~x</code>。</li>
<li>对每一个比特位执行非（<code>NOT</code>）操作。<code>NOT a</code> 结果为 <code>a</code> 的反码。对任一数值 <code>x</code> 进行按位非操作的结果为 <code>-(x + 1)</code>。比如 <code>~str.indexOf(searchFor)</code> 可以判断字符 <code>searchFor</code> 是否在 <code>str</code> 中出现，当 <code>indexOf</code> 返回 <code>-1</code> 时，<code>~str.indexOf(searchFor)</code> 的结果为 <code>0</code>。</li>
</ul>
<blockquote>
<p>这里需要注意，所有的按位操作符都是用 <code>32</code> 位<strong>有符号二进制补码</strong>进行计算的，所以上面的位匹配规则中用 <code>-1</code> 来说明，在补码中 <code>-1</code> 就是全为 <code>1</code>。<code>~x</code> 表示 <code>x</code> 取反。<code>NaN</code> 作为操作数的表现和 <code>0</code> 相同，比如 <code>({}) &amp; -1</code> 的结果为 <code>0</code>。</p>
</blockquote>
<h4 id="按位移动操作符">按位移动操作符</h4>
<p>按位移动操作符（按位左移 <code>&lt;&lt;</code>，有符号按位右移 <code>&gt;&gt;</code>，无符号按位右移 <code>&gt;&gt;&gt;</code>）有两个操作数：第一个是要被移动的数字，而第二个是要移动的长度。移动的方向根据操作符的不同而不同。</p>
<p>按位移动会先将操作数转换为大端字节序顺序(<code>big-endian order</code>)的 <code>32</code> 位整数,并返回与左操作数相同类型的结果。右操作数应小于 <code>32</code> 位，否则只有最低 <code>5</code> 个字节会被使用。</p>
<blockquote>
<p><code>Big-Endian</code>:高位字节排放在内存的低地址端，低位字节排放在内存的高地址端，又称为&quot;高位编址&quot;，是最直观的字节序。</p>
</blockquote>
<ul>
<li>按位左移 <code>&lt;&lt;</code>：该操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 <code>0</code> 补充。<code>9 &lt;&lt; 2</code> 结果为 <code>36</code>，即 <code>1001</code> 变为 <code>100100</code>。</li>
<li>有符号按位右移 <code>&gt;&gt;</code>：该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。<code>9&gt;&gt;2</code> 结果为 <code>2</code>，即 <code>1001</code> 变为 <code>0010</code>；<code>-9&gt;&gt;2</code> 结果为 <code>-3</code>，即 <code>11111111111111111111111111110111</code> 变为 <code>11111111111111111111111111111101</code>。</li>
<li>无符号按位右移 <code>&lt;&lt;</code>：该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用 <code>0</code> 填充。因为符号位变成了 <code>0</code>，所以结果总是非负的。对于非负数，有符号右移和无符号右移总是返回相同的结果。（即便右移 <code>0</code> 个比特，结果也是非负的，可以理解为将补码直接当做正数，比如 <code>--1</code> 的补码是 <code>32</code> 个 <code>1</code>，那么 <code>-1 &gt;&gt;&gt;0</code> 的结果就是 <code>4294967295</code>）</li>
</ul>
<h3 id="应用">应用</h3>
<p>上面介绍了 <code>JavaScript</code> 中的位运算概念，本节介绍一些比较常见的应用场景。</p>
<h4 id="掩码-bitmask">掩码 bitmask</h4>
<p>所谓掩码其实就是一串二进制数，我们通过 <strong>与/或</strong> 的操作来读取标志位。主要利用的特性就是任何数与 <code>0</code> 进行<strong>与</strong>操作都是 <code>0</code>，任何数与 <code>1</code> 进行<strong>或</strong>操作都是 <code>1</code>。</p>
<p>比如我们常见的子网掩码就是一种应用，为了区分我们 <code>IP</code> 地址中的网络号与主机号，用子网掩码来做 <strong>与</strong> 操作即可。我们的 <code>IP</code> 的地址是 <code>4</code> 字节，子网掩码也是 <code>4</code> 字节，当我们的子网掩码是 <code>255.255.255.0</code> 的时候，其实就是 <code>11111111.11111111.11111111.00000000</code>，当我们的 <code>IP</code> 地址和子网掩码进行<strong>与</strong>操作之后，只会留下前面 <code>24</code> 位，这 <code>24</code> 位也就是我们的主机号。也就是说，子网掩码就是将网络号对应的位全部设为 <code>1</code>，而主机号的位设为 <code>0</code>，可以很方便的知道我们的网络号和主机号。</p>
<p>在 <code>JavaScript</code> 中也有应用，比如 <code>MouseEvent.buttons</code> 就是用的掩码的形式来分辨当前按下了哪些鼠标上的键，用六位二进制数作为标志位，</p>
<ul>
<li>0  : 没有按键或者是没有初始化</li>
<li>1  : 鼠标左键</li>
<li>2  : 鼠标右键</li>
<li>4  : 鼠标滚轮或者是中键</li>
<li>8  : 第四按键 (通常是“浏览器后退”按键)</li>
<li>16 : 第五按键 (通常是“浏览器前进”)</li>
</ul>
<p>我们可以利用掩码来进行一些状态的保存和判断，用法主要是</p>
<ul>
<li>用<strong>或</strong>运算设置标志位，掩码中为 <code>1</code> 的位可以设置对应的位，比如 <code>0011</code> 就可以将最后两位都设置为 <code>1</code>。</li>
<li>用<strong>与</strong>运算清除标志位，利用掩码中的 <code>0</code> 将目标位置进行重置。比如 <code>0000</code> 可以将目标的四位全部置为 <code>0</code>。</li>
<li>用<strong>与</strong>运算获得目标位置的状态，比如 <code>0010</code> 与目标进行<strong>与</strong>运算可以获得目标第三位的状态。</li>
<li>用<strong>异或</strong>运算切换标志位状态，掩码中的 <code>1</code> 能够让目标位置的状态切换。</li>
</ul>
<p>我们可以用左移运算符进行掩码的自动化创建，无符号右移将掩码转化为布尔值：</p>
<pre><code class="language-javascript">//布尔值转掩码
function createMask () {
  var nMask = 0, nFlag = 0, nLen = arguments.length &gt; 32 ? 32 : arguments.length;
  for (nFlag; nFlag &lt; nLen; nMask |= arguments[nFlag] &lt;&lt; nFlag++);
  return nMask;
}
var mask1 = createMask(true, true, false, true); // 11, 0b1011
var mask2 = createMask(false, false, true); // 4, 0b0100
var mask3 = createMask(true); // 1, 0b0001

//掩码转布尔值
function arrayFromMask (nMask) {
  // nMask 必须介于 -2147483648 和 2147483647 之间，去除符号位还有31位
  if (nMask &gt; 0x7fffffff || nMask &lt; -0x80000000) { 
    throw new TypeError(&quot;arrayFromMask - out of range&quot;); 
  }
  for (var nShifted = nMask, aFromMask = []; nShifted; 
       aFromMask.push(Boolean(nShifted &amp; 1)), nShifted &gt;&gt;&gt;= 1);
  return aFromMask;
}

var array1 = arrayFromMask(11); //[true, true, false, true]
var array2 = arrayFromMask(4); //[false, false, true]
var array3 = arrayFromMask(1); //[true]
</code></pre>
<h4 id="乘除">乘除</h4>
<p>我们的右移相当于<strong>除2</strong>，左移相当于<strong>乘2</strong>。</p>
<pre><code class="language-javascript">let a = -10;
a &gt;&gt; 1; // -5
a &lt;&lt; 1; // -20
</code></pre>
<h4 id="交换两个数的值">交换两个数的值</h4>
<p>利用异或的特点，我们可以不创建第三个变量进行两个变量值的交换，</p>
<pre><code class="language-javascript">let a = 100, b = -100;
a ^ = b; //a = a ^ b
b ^ = a; //b = b ^ b ^ a -&gt; a
a ^ = b; // a = a ^ a ^ b -&gt; b
</code></pre>
<p>这主要利用的是异或的交换律，即 <code>a ^ b</code> 和 <code>b ^ a</code> 是相等的；以及异或自身的结果为 <code>0</code>，任何值和 <code>0</code> 进行异或结果都为自身。</p>
<h4 id="判断奇偶">判断奇偶</h4>
<p>二进制数只有最后一位是 <code>0</code> 就是偶数，最后一位是 <code>1</code> 就是奇数，我们可以利用这一点进行判断，</p>
<pre><code class="language-javascript">if ( 0 === (a &amp; 1)) {
	console.log('an even number')
} else {
	console.log('an odd number')
}
</code></pre>
<h4 id="变更符号">变更符号</h4>
<p>对于二进制补码，有 <code>X + ~X + 1 = 0</code>，变形可得 <code>-X = ~X + 1</code>，所以一个数的相反数就是按位取反再加一。</p>
<pre><code class="language-javascript">let a = 10;
console.log(~a + 1); //-10
</code></pre>
<p>利用这一特性我们也可以求绝对值，只要先判断值的正负即可。利用 <code>a &gt;&gt; 31</code> 即可判断正负，正数右移 <code>31</code> 位后结果为 <code>0</code>，负数右移 <code>31</code> 位后结果为 <code>-1</code>，如果是负数则求其相反数。求绝对值还有一个更简化一点的办法：</p>
<pre><code class="language-javascript">let a = -10
let i = a &gt;&gt; 31;
console.log((a^i) - i); //10
</code></pre>
<p>主要就是利用任何数与 <code>-1</code> 进行异或运算就是取反。</p>
<h4 id="高低位交换">高低位交换</h4>
<p>比如一个 <code>16位</code> 无符号整数，我们可以利用位运算进行高八位第八位的交换。<code>a &lt;&lt; 8 | a &gt;&gt; 8</code></p>
<h4 id="求最小的2的整数次幂约数">求最小的2的整数次幂约数</h4>
<p>给定一个数，想求其最小的整数次幂约数可以用 <code>a &amp; -a</code>。求最小的 <code>2</code> 的整数次幂约数其实就是找其二进制表示中从右往左数第一个 <code>1</code>。利用 <code>-a = ~a + 1</code> 可以找到这个 <code>1</code> 的位置。</p>
<h4 id="计算二进制数中-1-的个数">计算二进制数中 <code>1</code> 的个数</h4>
<pre><code class="language-javascript">let count = 0;
let a = 100;
while(a){
  a = a &amp; (a - 1);
  count++;
}
console.log(count) //3
console.log(100. toString(2)) //1100100
</code></pre>
<h3 id="参考文章">参考文章</h3>
<ol>
<li><a href="https://www.zhihu.com/question/38206659/answer/736472332" title="位运算有什么奇技淫巧？ - 力扣（LeetCode）的回答 - 知乎 ">位运算有什么奇技淫巧？ - 力扣（LeetCode）的回答 - 知乎 </a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" title="按位操作符 - MDN">按位操作符 - MDN</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实现一个 JS 动画模块]]></title>
        <id>https://clloz.github.io/post/js-animation-module/</id>
        <link href="https://clloz.github.io/post/js-animation-module/">
        </link>
        <updated>2020-09-27T16:31:22.000Z</updated>
        <summary type="html"><![CDATA[<p>用 JavaScript 实现一个元素动画管理模块，能够支持多元素的动画管理，动画暂停，恢复，延迟和三次贝塞尔曲线的支持。</p>
]]></summary>
        <content type="html"><![CDATA[<p>用 JavaScript 实现一个元素动画管理模块，能够支持多元素的动画管理，动画暂停，恢复，延迟和三次贝塞尔曲线的支持。</p>
<!-- more -->
<p id="my-logo"><a href="https://www.clloz.com">Clloz</a></p>
<p>本文首发于个人博客<a href="https://www.clloz.com">clloz.com</a></p>
<h3 id="前言">前言</h3>
<p>前端的动画可以用 <code>CSS</code> 来实现，但是如果我们希望管理多个元素的动画进行，支持暂停和继续。那么我们可以用 <code>JS</code> 来实现。</p>
<h3 id="功能分析">功能分析</h3>
<p>用 <code>CSS</code> 实现动画是用 <code>keyframe</code> 定义关键帧，然后用 <code>animation</code> 属性对关键帧的过渡进行配置，其中比较常用的几个属性是 <code>animation-na'me, animation-delay, animation-duration, animation-timing-function</code>（详细内容参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations/Using_CSS_animations" title="使用 CSS 动画 - MDN">使用 CSS 动画 - MDN</a>）。</p>
<p>使用 <code>JavaScript</code> 来实现动画就是根据时间计算出对应时间点的元素样式。用 <code>JavaScript</code> 的好处是我们能够将动画的逻辑抽象出来，能够同时管理各种需要进行动画元素，并且我们能够对元素的动画进行更精确的控制，精确到帧。</p>
<p>从分析中我们可以得出，我们用 <code>JavaScript</code> 实现动画的核心就是对时间的把控，我们要明确每一帧元素应该处于什么样的状态。浏览器中一帧是 <code>16ms</code> （一秒钟 <code>60</code> 帧），我们要实现对每一帧的控制可以使用的几个方法是 <code>setInterval</code>，<code>setTimeout</code> 和 <code>requestAnimationFrame</code>。本文我们用 <code>requestAnimationFrame</code> 来实现。<code>requestAnimationFrame</code> 的 <code>API</code> 参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" title="window.requestAnimationRequest">window.requestAnimationRequest</a></p>
<h3 id="动画类">动画类</h3>
<p>首先要设计一个动画类，这个动画类主要是对元素和动画属性的对象进行初始化，同时根据时间计算当前元素的样式。代码如下：</p>
<pre><code class="language-javascript">class Animation {
    constructor(obj, prop, startVal, endVal, duration, delay, timeFunc, template) {
        this.obj = obj;
        this.prop = prop;
        this.startVal = startVal;
        this.endVal = endVal;
        this.duration = duration;
        this.delay = delay;
        this.timeFunc = timeFunc;
        this.template = template;
    }
    trans(time) {
        console.log(time);
        let range = this.endVal - this.startVal;
        let progress = this.timeFunc(time / this.duration);
        this.obj[this.prop] = this.template(this.startVal + range * progress);
    }
}
</code></pre>
<p>参数中的 <code>obj</code> 是表示要应用动画的元素，<code>prop</code> 是要进行动画的属性，<code>timeFunc</code> 是和 <code>css</code> 中的 <code>animation-timing-function</code> 类似，<code>template</code> 是为了应对不同的 <code>CSS</code> 属性的不同格式，比如 <code>transform</code> 属性。</p>
<h3 id="timeline类">timeline类</h3>
<p>我们要对动画实现 <code>start</code>，<code>pause</code>，<code>resume</code> 等功能，需要一个 <code>timeline</code> 对时间进行管理。我们的 <code>Animation</code> 是根据时间计算样式的，这个时间是一个相对时间。比如 <code>pause</code> 功能，我们可以在用户点击 <code>pause</code> 按钮后记录时间，然后在用户点击 <code>resume</code> 按钮后计算出暂停的时间，在返回给 <code>Animation.trans()</code> 方法的时间中减去这个暂停的时间就能够让元素继续暂停之前的状态进行动画。</p>
<p>对于不同的元素的动画我们用 <code>Set</code> 进行管理，当有新的需要动画的元素加入时我们将 <code>new</code> 的 <code>Animation</code> 对象存入 <code>Set</code>，当动画完成在从 <code>Set</code> 中删除。</p>
<p>整个的逻辑还是比较简单的，直接看代码吧.</p>
<pre><code class="language-javascript">const TICK = Symbol('tick');
const TICK_HANDLER = Symbol('tick handler');
const ANIMATIONS = Symbol('animations');
const MOVETIME = Symbol('movetime');
const PAUSE_START = Symbol('pause start');
const PAUSE_TIME = Symbol('pause time');

export class Timeline {
    constructor() {
        this.state = 'inited';
        this[ANIMATIONS] = new Set();
        this[MOVETIME] = new Map();
    }
    start() {
        if (this.state !== 'inited') return;
        this.state = 'started';
        let startTime = Date.now();
        this[PAUSE_TIME] = 0;
        console.log(startTime);
        this[TICK] = () =&gt; {
            let now = Date.now();
            for (let animation of this[ANIMATIONS]) {
                let t;
                if (this[MOVETIME].get(animation) &lt; startTime) {
                    t = now - startTime - this[PAUSE_TIME] - animation.delay;
                } else {
                    t = now - this[MOVETIME].get(animation) - this[PAUSE_TIME] - animation.delay;
                }
                if (t &gt; animation.duration) {
                    this[ANIMATIONS].delete(animation);
                    t = animation.duration;
                }
                if (t &gt; 0) animation.trans(t);
            }
            this[TICK_HANDLER] = requestAnimationFrame(this[TICK]);
        };
        this[TICK]();
    }
    pause() {
        if (this.state !== 'started') return;
        this.state = 'paused';
        this[PAUSE_START] = Date.now();
        cancelAnimationFrame(this[TICK_HANDLER]);
    }
    resume() {
        if (this.state !== 'paused') return;
        this.state = 'started';
        this[PAUSE_TIME] += Date.now() - this[PAUSE_START];
        this[TICK]();
    }
    reset() {
        this.pause();
        this.state = 'inited';
        // let startTime = Date.now();
        this[ANIMATIONS] = new Set();
        this[MOVETIME] = new Map();
        this[TICK_HANDLER] = null;
        this[PAUSE_START] = 0;
    }
    add(animation, startTime) {
        if (arguments.length &lt; 2) {
            startTime = Date.now();
        }
        this[ANIMATIONS].add(animation);
        this[MOVETIME].set(animation, startTime);
    }
}
</code></pre>
<p>一些模块中私有的属性，我用 <code>Symbol</code> 来生成，这样在模块文件外这些属性是不会被访问到的（目前 <code>ES6</code> 的静态属性支持还不好）。对于 <code>delay</code> 的处理其实和 <code>pause</code> 的逻辑也一样，我们记录 <code>start</code> 开始的时间，只有等到时间超过 <code>delay</code> 才会调用。注意我们的时间计算是从 <code>start</code> 开始一直到结束的，所以每次的 <code>pause</code> 的时间都需要累加到 <code>pause time</code> 中。</p>
<p>时间的前进我们利用 <code>requestAnimationFrame</code> 的回调函数来递归调用我们封装的函数实现。</p>
<p>最后我们可以为动画加上贝塞尔曲线的支持。</p>
<pre><code class="language-javascript">export function cubicBezier(p1x, p1y, p2x, p2y) {
    const ZERO_LIMIT = 1e-6;
    const ax = 3 * p1x - 3 * p2x + 1;
    const bx = 3 * p2x - 6 * p1x;
    const cx = 3 * p1x;

    const ay = 3 * p1y - 3 * p2y + 1;
    const by = 3 * p2y - 6 * p1y;
    const cy = 3 * p1y;
    function sampleCurveDerivativeX(t) {
        return (3 * ax * t + 2 * bx) * t + cx;
    }
    function sampleCurveX(t) {
        return ((ax * t + bx) * t + cx) * t;
    }
    function sampleCurveY(t) {
        return ((ay * t + by) * t + cy) * t;
    }
    function solveCurveX(x) {
        var t2 = x;
        var derivative;
        var x2;
        for (let i = 0; i &lt; 8; i++) {
            x2 = sampleCurveX(t2) - x;
            if (Math.abs(x2) &lt; ZERO_LIMIT) {
                return t2;
            }
            derivative = sampleCurveDerivativeX(t2);
            if (Math.abs(derivative) &lt; ZERO_LIMIT) {
                break;
            }
            t2 -= x2 / derivative;
        }
        var t1 = 1;
        var t0 = 0;
        t2 = x;
        while (t1 &gt; t0) {
            x2 = sampleCurveX(t2) - x;
            if (Math.abs(x2) &lt; ZERO_LIMIT) {
                return t2;
            }
            if (x2 &gt; 0) {
                t1 = t2;
            } else {
                t0 = t2;
            }
            t2 = (t1 + t0) / 2;
        }
        return t2;
    }
    function solve(x) {
        return sampleCurveY(solveCurveX(x));
    }
    return solve;
}

export let ease = cubicBezier(0.25, 0.1, 0.25, 1);
export let easeIn = cubicBezier(0.42, 0, 1, 1);
export let easeOut = cubicBezier(0, 0, 0.58, 1);
export let easeInOut = cubicBezier(0.42, 0, 0.58, 1);
</code></pre>
<p>效果查看点击：<a href="https://cdn.clloz.com/study/js-animation" rel="noreferrer noopener" target="_blank">效果Demo</a></p>
<p>代码地址：<a href="https://github.com/Clloz/Frontend-02-Template/tree/master/week13/animation" title="Github">Github</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一台设备添加多个 Github 账号]]></title>
        <id>https://clloz.github.io/post/ssh-multiple-github-account/</id>
        <link href="https://clloz.github.io/post/ssh-multiple-github-account/">
        </link>
        <updated>2020-09-26T10:49:46.000Z</updated>
        <summary type="html"><![CDATA[<p>如何在同一台机器上添加多个 Github 的 ssh 公私钥，来完成不同的仓库的工作。本文分享配置过程和使用教程。</p>
]]></summary>
        <content type="html"><![CDATA[<p>如何在同一台机器上添加多个 Github 的 ssh 公私钥，来完成不同的仓库的工作。本文分享配置过程和使用教程。</p>
<!-- more -->
<p id="my-logo"><a href="https://www.clloz.com">Clloz</a></p>
<p>本文首发于个人博客<a href="https://www.clloz.com">clloz.com</a></p>
<h3 id="前言">前言</h3>
<p>想要深入学习 <code>Git</code> 肯定要模拟多人操作同一个仓库，最好的方法就是自己创建两个账号进行模拟。<code>Github</code> 的账号注册很简单，但是一般我们在一台设备上只配置一个 <code>ssh</code> 公私钥，多个账号的 <code>ssh</code> 该如何配置呢。在谷歌上找的文章没有一个讲的特别清楚的，不过经过我的尝试，已经把配置和使用过程搞清楚了，本文和大家分享一下。</p>
<h3 id="准备">准备</h3>
<p>准备工作就是两个 <code>Github</code> 账号和两对 <code>ssh</code> 公私钥。<code>Github</code> 的账号注册就不说了，<code>ssh</code> 的公私钥的创建可以参考<a href="https://www.clloz.com/programming/assorted/2019/10/02/ssh-rsa/" title="ssh的简介和使用">ssh的简介和使用</a>。这里特别提一下，<code>ssh</code> 默认创建的公私钥文件名分别是 <code>id_rsa</code> 和 <code>id_rsa.pub</code>，为了清楚的区分我们是为 <code>Github</code> 创建的公私钥我们可以加上 <code>-f location</code> 参数来指定生成的文件的路径和名字，比如 <code>-f ~/.ssh/github1</code> 就会生成 <code>github1</code> 和 <code>github1.pub</code> 这一对公私钥。</p>
<p>然后将两个公钥分别放到自己注册的两个 <code>Gihub</code> 账号的 <code>Settings -&gt; SSH and GPG keys</code> 中。</p>
<blockquote>
<p>注册账号的时候如果 <code>verify</code> 页面报错 <code>Unable to verify your captcha response</code>，很可能是连不上 <code>https://octocaptcha.com/</code>，需要代理。</p>
</blockquote>
<h3 id="设置过程">设置过程</h3>
<p>现在我们已经生成两对公私钥，并且公钥也配置到对应的账户中去了，下面就是对机器的配置。</p>
<p>我们通过 <code>ssh</code> 访问 <code>Github</code> 的项目。比如 <code>git clone</code>，<code>Github</code> 会给我们一个项目链接形如 <code>git@github.com:username/repository_name.git</code>，这个 <code>git@github.com</code> 就是我们连接 <code>Github</code> 的关键。当我们的设备中只有一对默认公私钥 <code>id_rsa</code> 的时候，<code>ssh</code> 请求默认就会认为私钥是 <code>id_rsa</code>，从而进行匹配。</p>
<p>但是当我们的 <code>.ssh</code> 文件夹中有两对甚至更多的公私钥的时候，并且我们进行了自定义的命名，此时我们就要对公私钥进行配置，告诉 <code>ssh</code> 如何寻找对应的私钥。</p>
<p>配置文件位于 <code>~/.ssh/config</code>，如何配置看下面的例子。更多 <code>ssh config</code> 的配置字段参考 <a href="https://deepzz.com/post/how-to-setup-ssh-config.html" title="SSH Config 那些你所知道和不知道的事">SSH Config 那些你所知道和不知道的事</a></p>
<pre><code class="language-bash">#Github clloz@outlook.com
host github.com
    hostname github.com
    User Clloz
    IdentityFile /Users/clloz/.ssh/Clloz_Github

#Github clloz1992@gmail.com
host clloz1992
    hostname github.com
    User Clloz1992
    IdentityFile /Users/clloz/.ssh/Clloz1992_Github
</code></pre>
<p>这几个字段意思如下:</p>
<ul>
<li><code>Host</code>: 我们上面说过 <code>Github</code> 的链接是 <code>git@github.com</code>，这个 <code>host</code> 就是我们自定义的，下面的 <code>hostname</code> 别名。</li>
<li><code>hostname</code>：<code>Github</code> 域名，其实 <code>IP</code> 也可以，我们和 <code>git</code> 进行 <code>ssh</code> 通信的时候，请求从这个地址来。</li>
<li><code>user</code>：我们在 <code>Github</code> 上注册的用户名（好像邮箱也可以）。</li>
<li><code>IdentityFile</code>：对应的<strong>私钥</strong>的路径。</li>
</ul>
<p>这里特别提一下 <code>Host</code> 这个字段，理论上这个字段可以自定义，但是我建议你常用的那个 <code>GIthub</code> 账号这个字段就使用 <code>github.com</code>。首先我们说一下配置生效的原理，所有的 <code>Github</code> 的仓库的地址默认都是 <code>git@github.com</code> 开头，无论是来自哪个用户，也就是说 <code>hostname</code> 都是 <code>github.com</code>。现在我们在 <code>config</code> 文件中，为 <code>github.com</code> 指定了两个别名 <code>allias1</code> 和 <code>alias2</code>，现在我们设置 <code>remote</code> 或者 <code>git clone</code> 的时候不再是使用 <code>git@github.com</code>，而是换成 <code>git@alias1</code> 和 <code>git@alias2</code>。这样配置以后，每次用 <code>ssh</code> 通信的时候我们用别名做 <code>host</code>，而每个别名对应的私钥都在 <code>identityfile</code> 字段中配置了，自然能够成功的按账号进行区分。简单的说，<strong>就是原本我们的公私钥是按照 <code>hostname</code> 来匹配的，但是由于 <code>github</code> 的所有仓库 <code>hostname</code> 都一样，无法对用户进行区分，我们就用别名来设置 <code>host</code> 进行区分，别名的作用就类似于用户名</strong>，</p>
<p>而由于 <code>Github</code> 上复制地址的时候默认就是 <code>git@github.com</code>，如果你将 <code>host</code> 自定义成其他的，每次 <code>git clone</code> 都要手动改一下 <code>host</code>，非常麻烦。如果不改的话将无法对仓库进行任何操作，因为此时 <code>github.com</code> 这个 <code>host</code> 在我们本地的 <code>ssh</code> 中是找不到对应的私钥的。而且如果你的本地本来就有很多原来 <code>clone</code> 的项目，他们的 <code>host</code> 都是 <code>github.com</code>，此时你也不能对他们进行任何操作，<code>git pull</code> 都不可以，你必须将 <code>remote</code> 修改为你配置后的 <code>host</code> 才能正常操作，如果本地仓库非常多的话，这将非常麻烦。关于报错可以参考下面的我将 <code>host</code> 改为一个自定义的值之后，对原来的 <code>github.com</code> 的仓库进行 <code>git pull</code> 报错如下：</p>
<pre><code class="language-bash">git@github.com: Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
</code></pre>
<p>都设置完成后我们可以用 <code>ssh -T host_alias</code> 来进行测试，如果 <code>host</code> 和返回的用户名匹配成功则说明我们的设置生效了。</p>
<pre><code class="language-bash">ssh -T git@clloz1992
#Hi Clloz1992! You've successfully authenticated, but GitHub does not provide shell access.

ssh -T git@github.com
#Hi Clloz! You've successfully authenticated, but GitHub does not provide shell access.
</code></pre>
<hr>
<p>经过上面的配置以后，我们已经能够正常的进行两个 <code>github</code> 账号的仓库管理了。需要注意的是分清楚当前仓库是属于哪个用户的。比如 <code>account1</code> 对应的 <code>host</code> 是 <code>allias1</code>，<code>accout2</code> 对应的 <code>host</code> 是 <code>alias2</code>，那么你 <code>clone</code> 或者设置 <code>remote</code> 的时候地址就要将 <code>github.com</code> 改为对应的 <code>alias</code>。如果你在 <code>accout2</code> 下面创建了一个仓库，然后 <code>clone</code> 的时候用的是 <code>git clone git@alias1:username/repository_name.git</code>。那么你会发现，当你进行 <code>push</code> 的时候会报如下的错误：</p>
<pre><code class="language-bash">ERROR: Permission to Clloz/git_learning.git denied to Clloz1992.
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
</code></pre>
<p>因为这是 <code>alias1</code> 的仓库，我们自然没有权限对其进行操作。不过我们可以登录 <code>alias1</code> 的 <code>Github</code> 账户，在对应的 <code>repository</code> 的 <code>Settings -&gt; Manage Access</code> 中将 <code>allias2</code> 对应的用户添加到 <code>Collaborator</code> 中，我们就能对这个仓库进行操作了。</p>
<hr>
<p>还有一点需要注意的，在 <code>git config --global</code> 中的 <code>user.name</code> 和 <code>user.email</code> 我们可以设置为常用账户的，在 <code>alias2</code> 的本地仓库中我们可以用 <code>git config --local</code> 进行单独的设置。我们在 <code>Github</code> 中看到的 <code>commit</code> 就是根据 <code>config</code> 来确定是哪个 <code>github</code> 用户提交的。比如我在 <code>alias2</code> 的仓库中设置 <code>config</code> 的 <code>user.name</code> 和 <code>user.email</code> 为 <code>alias1</code> 对应的用户信息然后进行 <code>commit push</code>，那么在 <code>github</code> 上看到的提交就是由 <code>alias1</code> 对用的用户完成的，<code>contributor</code> 中也多了 <code>alias1</code> 对应的用户，虽然我们并没有把他加入到 <code>Collaborator</code> 中。</p>
<p>所以如果我们只是要模拟多人提交，我们也不必在本地配置两个 <code>github</code> 账户的 <code>ssh</code>，我们可以用同一个账号 <code>clone</code> 将 <code>repository</code> 克隆到两个不同的文件夹，然后两个文件夹的 <code>.git/config</code> 中的 <code>user.name</code> 和 <code>user.email</code> 配置成我们对应的 <code>github</code> 账号的就可以。因为 <code>github</code> 分辨 <code>commit</code> 的来源是根据 <code>config</code> 中的 <code>user</code> 信息的。</p>
<p>所以我们总结一下：<code>ssh</code> 的公私钥只是根据 <code>host</code> 确定了当前的设备是否有权限访问某个 <code>Github</code> 下的仓库；而 <code>config</code> 中的 <code>user</code> 信息确定了当前在操作仓库的是谁。</p>
<h3 id="ssh-agent">ssh-agent</h3>
<p>最后再说一下 <code>ssh-agent</code>。关于 <code>ssh-agent</code> 的详细内容还是看<a href="https://www.clloz.com/programming/assorted/2019/10/02/ssh-rsa/" title="ssh的简介和使用">ssh的简介和使用</a>，我这里主要要说的是，如果你为私钥设置了 <code>passphrase</code>，想要使用 <code>ssh-agent</code>，那么你<strong>必须把两个账号的私钥都交给 <code>ssh-agent</code> 来代理</strong>，否则会出错。</p>
<h3 id="参考文章">参考文章</h3>
<ol>
<li><a href="https://github.com/jawil/notes/issues/2" title="同一台电脑配置多个git账号">同一台电脑配置多个git账号</a></li>
<li><a href="https://www.cnblogs.com/fanbi/p/7825746.html" title="一台电脑，两个及多个git账号配置">一台电脑，两个及多个git账号配置</a></li>
<li><a href="https://me.chjiyun.com/2017/08/28/%E5%A4%9A%E4%B8%AA%E5%AF%86%E9%92%A5ssh-key%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E7%AE%A1%E7%90%86/" title="多个密钥ssh-key的生成与管理">多个密钥ssh-key的生成与管理</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS实现视差滚动 Parallax Scrolling]]></title>
        <id>https://clloz.github.io/post/parallax-scrolling/</id>
        <link href="https://clloz.github.io/post/parallax-scrolling/">
        </link>
        <updated>2020-09-24T11:54:10.000Z</updated>
        <summary type="html"><![CDATA[<p>使用纯 CSS 的方式实现视差滚动效果，主要是利用透视的原理让元素的滚动产生差异，从而达到视觉效果。</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用纯 CSS 的方式实现视差滚动效果，主要是利用透视的原理让元素的滚动产生差异，从而达到视觉效果。</p>
<!-- more -->
<p id="my-logo"><a href="https://www.clloz.com">Clloz</a></p>
<p>本文首发于个人博客<a href="https://www.clloz.com">clloz.com</a></p>
<h3 id="前言">前言</h3>
<p>在博客首页的头部背景图本来是用 <code>JavaScript</code> 实现的视差滚动，但是觉得性能不是很好。于是尝试用 <code>CSS</code> 来实现视差滚动的效果。</p>
<h3 id="原理">原理</h3>
<p>用 <code>CSS</code> 实现视差滚动的原理就是利用 <code>3d</code> 空间的 <code>z</code> 轴距离产生的近大远小，让元素之间的滚动距离产生差距。<code>perspective</code> 的属性值确定观察的 <code>z</code> 轴坐标，比如我们设 <code>perspective: 1px</code>，最后所有的透视效果都是以和 <code>z = 1px</code> 的位置观察的效果是相同的。<code>z</code> 轴的原点就是我们的屏幕，所有的最后显示效果，都是投影在屏幕上的效果。如果以人眼作为比喻的话，<code>perspective</code> 就是我们的眼睛位置，而屏幕就是视网膜的位置。</p>
<p>如果我们以 <code>z = -1px</code> 为观察点，在z <code>z = 0</code> 和 <code>z= -1px</code> 的位置放两个相同长度的元素，那么实际的成像效果就后面的元素只有前面的元素的长度的一半。如果我们想要让位于 <code>z = -1px</code> 位置的元素看上去和 <code>z = 0</code> 的元素一样大，那么我们就需要将它的边长放大到两倍，可以用 <code>scale(2)</code> 实现。放大后，从我们的 <code>perspective</code> 位置看上去就和 <code>z = 0</code> 的元素是一样的，但是如果我们对屏幕进行滚动，可以理解为我们将我们的观察点沿着 <code>y</code> 轴上下移动，这个位移对于 <code>z = 0</code> 和 <code>z = -1px</code> 的元素是相同的，但是由于 <code>z = -1px</code> 的元素的边长是 <code>z = 0</code> 位置元素的两倍，所以视觉上，我们觉得 <code>z = -1px</code> 的元素的位移好像更短，这就是视差效果。</p>
<p>详细的研究和推理过程可以参考 <a href="https://css-tricks.com/tour-performant-responsive-css-site/" title="Tour of a Performant and Responsive CSS Only Site">Tour of a Performant and Responsive CSS Only Site</a></p>
<h3 id="实现">实现</h3>
<p>有了原理之后，实现就简单了。我们将要进行视差移动的元素放到 <code>-1px</code> 的位置，同时放大两倍，将 <code>perspective</code> 设置到 <code>1px</code> 即可。</p>
<pre><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
        &lt;title&gt;parallax&lt;/title&gt;
        &lt;style&gt;
            html,
            body {
                height: 100%;
                margin: 0;
            }
            .container {
                position: relative;
                height: 100%;
                overflow: auto;
                perspective: 1px;
                perspective-origin: 0 0;
            }
            .bg {
                /* position: absolute; */
                width: 100%;
                height: 600px;
                background-image: url('bg.jpg');
                background-size: cover;
                transform-origin: 0 0;
                transform: translateZ(-1px) scale(2);
            }
            .content {
                height: 3000px;
                background: pink;
                margin: -60px 15px 0;
                position: relative;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;div class=&quot;bg&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>效果可以查看：<a href="https://cdn.clloz.com/study/parallax_scroll.html" target="_blank" rel="noopener noreferrer">效果Demo</a></p>
<h3 id="总结">总结</h3>
<p>这种 <code>CSS</code> 实现的视差滚动效果在手机上没法达到效果，手机上可以实现透视的效果，但是滚动的效果出不来。最终我也没有应用到博客上。几种视差滚动的实现方式，包括 <code>js</code>，<code>background-attachment</code> 和 透视，都没有一个十分满意的方法，因为性能都不是非常好，而且改动也非常多，最后我干脆就把把这个效果拿掉了，</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图片轮播]]></title>
        <id>https://clloz.github.io/post/carousel/</id>
        <link href="https://clloz.github.io/post/carousel/">
        </link>
        <updated>2020-09-22T11:59:17.000Z</updated>
        <summary type="html"><![CDATA[<p>本文用两种方式实现图片轮播的效果，包括自动轮播和拖动轮播。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文用两种方式实现图片轮播的效果，包括自动轮播和拖动轮播。</p>
<!-- more -->
<p id="my-logo"><a href="https://www.clloz.com">Clloz</a></p>
<p>本文首发于个人博客<a href="https://www.clloz.com">clloz.com</a></p>
<h3 id="前言">前言</h3>
<p>用两种方式实现图片轮播，自动轮播和拖动轮播。</p>
<h3 id="代码结构">代码结构</h3>
<p>由于 <code>img</code> 是一个可选标签，可以被拖动，我们这里选择用 <code>background-image</code> 来实现。基本的 <code>DOM</code> 结构和 <code>CSS</code> 如下：</p>
<pre><code class="language-html">&lt;style&gt;
	.carousel {
		width: 500px;
		height: 280px;
		margin: 30px auto;
		font-size: 0;
		white-space: nowrap;
		overflow: hidden;
	}
	.carousel &gt; div {
		display: inline-block;
		width: 500px;
		height: 280px;
		background-size: contain;
		transition: ease 0.5s;
	}
	.carousel &gt; div:nth-child(1) {
		background-image: url('https://img.clloz.com/blog/writing/cat1.jpg');
	}
	.carousel &gt; div:nth-child(2) {
		background-image: url('https://img.clloz.com/blog/writing/cat2.jpg');
	}
	.carousel &gt; div:nth-child(3) {
		background-image: url('https://img.clloz.com/blog/writing/cat3.jpg');
	}
	.carousel &gt; div:nth-child(4) {
		background-image: url('https://img.clloz.com/blog/writing/cat4.jpg');
	}
&lt;/style&gt;

&lt;div class=&quot;carousel cp1&quot;&gt;
	&lt;div&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;carousel cp2&quot;&gt;
	&lt;div&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>我们用 <code>display: inline-block</code> 和 <code>overflow: hidden</code> 让图片横向排列并且一次只显示一张。这里需要注意 <code>inline-block</code> 空格导致的间隙问题，我直接用 <code>font-size: 0</code> 来解决。</p>
<h3 id="自动轮播">自动轮播</h3>
<p>自动轮播的逻辑是比较简单的，我们其实只要关注两张图片，即当前图片和下一张图片。设每一张图片的编号为 <code>index</code> （从 <code>0</code> 开始），每一张图片要显示所对应的 <code>translateX</code> 的值就是 <code>-(index * 100)%</code>。所以我们只需要每次移动时将当前图片和下一章图片左移一个单位（即一张图片的宽度），同时将下一次要显示的图片放到当前图片的右边一个单位。如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://img.clloz.com/blog/writing/carousel.png" alt="carousel" title="carousel" loading="lazy"></figure>
<p>关键逻辑就是将下次要显示的图片移动到预备位置，并且这个过程要关掉动画效果。最后的代码如下：</p>
<pre><code class="language-javascript">// transform loop settimeout
let el2 = document.querySelector('.carousel.cp2');
let currentIndex = 0;
setInterval(() =&gt; {
	let children = el2.children;
	let nextIndex = (currentIndex + 1) % children.length;
	let current = children[currentIndex];
	let next = children[nextIndex];

	next.style.transition = 'none';
	next.style.transform = `translateX(${100 - nextIndex * 100}%)`;

	setTimeout(() =&gt; {
		next.style.transition = '';
		current.style.transform = `translateX(${-100 - currentIndex * 100}%)`;
		next.style.transform = `translateX(${-nextIndex * 100}%)`;
		currentIndex = nextIndex;
	}, 16);
}, 3000);
</code></pre>
<p>动画效果的开关我们可以用 <code>element.style.transition</code> 来控制行内样式的值来达到效果。因为行内样式的优先级最高，当我们设置其值为 <code>none</code> 会覆盖 <code>style</code> 标签中的样式。当我们将 <code>element.style.transition</code> 的值设为 <code>''</code>，<code>style</code> 标签中的对应样式又生效了</p>
<p>代码中间使用了一个小技巧。就是如果连续对同一个元素进行操作，浏览器会忽略前一个操作，这里我们用一个 <code>setTimeout</code> 避免浏览器的这种行为，<code>16ms</code> 为浏览器一帧的时间。</p>
<p>还有一点就是最后一张图片的下一张应该是第一张，这里我们可以使用简单的模运算来达到效果，模就是元素的个数。</p>
<h3 id="拖动轮播">拖动轮播</h3>
<p>拖动轮播的逻辑要比自动复杂一些，因为拖动的情况下我们既可以向左又可以向右进行拖动。并且当拖动结束的时候，显示窗口中会有两张图片，我们要根据面积来判断哪张图片显示，并且要把另一张图片也移动到窗口外。</p>
<p>首先我们要处理拖动事件，这个逻辑和我在<a href="https://www.clloz.com/programming/front-end/css/2020/09/18/spin-dice/" title="拖动旋转 3D 的骰子效果">拖动旋转 3D 的骰子效果</a>一文中的逻辑是相同，我们对包含元素，也就是代码中的 <code>.carousel</code> 绑定一个 <code>mousedown</code> 事件，在其回调函数中绑定 <code>mousemove</code> 和 <code>mouseup</code> 事件。注意后两个事件要绑定到 <code>document</code> 上，因为我们即使拖动到元素外也是一个完整的 <code>mousemove</code> 行为，并且绑定到 <code>document</code> 上即使我们拖出浏览器外也依然能保持触发 <code>mousemove</code> 事件。</p>
<p><code>mousedown</code> 事件我们只要做一件事就是记录用户点击的初始位置坐标，用 <code>clientX</code>（因为轮播是横向的，我们只需要判断 <code>x</code> 方向的移动距离）</p>
<p><code>mousemove</code> 我们要处理图片的移动，这里我们需要将动画效果关闭。以一张图片的的宽度为一个单位，我们只需要知道一共滚过了几个单位，就知道当前显示图片的 <code>index</code>，然后在计算当前 <code>index</code> 的前一张和后一张就能够得到连续的效果。<code>mousemove</code> 回调函数如下：</p>
<pre><code class="language-javascript">let move = e =&gt; {
	let x = e.clientX - startX;

	//拖动的整数屏
	let current = index - (x - (x % 500)) / 500;

	for (let offset of [-1, 0, 1]) {
		//计算可能出现的图片下标
		let pos = current + offset;
		pos = (pos + children.length) % children.length; //要处理大屏幕拖动小于 -children.length 的情况

		children[pos].style.transition = 'none';
		children[pos].style.transform = `translateX(${-pos * 500 + offset * 500 + (x % 500)}px)`; //当前，前一个，后一个图片当前位置
	}
};
</code></pre>
<hr>
<p><code>mouseup</code> 是这里面逻辑稍微复杂的一个，当我们拖动停止的时候，视口里面会有两张图片（一般情况下）（<code>x</code> 为 <code>e.clientX - startX</code>，即从触发 <code>mousedown</code> 到 <code>mouseup</code> 水平方向一共移动了多少像素），我们要判断哪张图片所占面积比较大，让这张图片用动画移动到整个视口，而另一张图片用动画移出视口。这里我讲两种实现方式。</p>
<p>第一种是比较好理解，但是代码量比较大。我们可以用 <code>(x - (x % 500)) / 500</code> 得出一共滚动了多少个单位，<code>index - (x - (x % 500)) / 500</code> 这张图片在触发 <code>mouseup</code> 时必然在视口内，只是我们不确定它是要移出的还是要显示的，我们只需要分情况，用 <code>if</code> 判断一下 <code>x % 500</code> 的各种情况。</p>
<p><code>x % 500</code> 的值就是页面滚动完整数个单位后多的部分，这部分如果超过一半的图片宽度，当前图片就要从视口移出；如果小于一半的图片宽度，当前图片就显示到视口中。同时我们还要判断视口中的另一张图片的移动方向，这里就不仅需要判断面积，同时需要判断是向左拖动还是向右拖动的。所以最后我们要 <code>2 x 2</code> 共四种情况。代码如下：</p>
<pre><code class="language-javascript">let up = e =&gt; {
	let x = e.clientX - startX;

	//index不变，向下取整，需要分情况，可读性好
	index = (index - (x - (x % 500)) / 500) % children.length;
	index = (index + children.length) % children.length;
	let base = x % 500;

	if (base &gt; 0) {
		if (base &gt; 250) {
			children[index].style.transition = '';
			children[index].style.transform = `translateX(${(-index + 1) * 500}px)`;
			let pre = index === 0 ? children.length - 1 : index - 1;
			children[pre].style.transition = '';
			children[pre].style.transform = `translateX(${-pre * 500}px)`;
			index = pre;
		} else {
			children[index].style.transition = '';
			children[index].style.transform = `translateX(${-index * 500}px)`;
			let pre = index === 0 ? children.length - 1 : index - 1;
			children[pre].style.transition = '';
			children[pre].style.transform = `translateX(${(-pre - 1) * 500}px)`;
		}
	}
	if (base &lt; 0) {
		if (base &lt; -250) {
			children[index].style.transition = '';
			children[index].style.transform = `translateX(${(-index - 1) * 500}px)`;
			let pre = index === 3 ? 0 : index + 1;
			children[pre].style.transition = '';
			children[pre].style.transform = `translateX(${-pre * 500}px)`;
			index = pre;
		} else {
			children[index].style.transition = '';
			children[index].style.transform = `translateX(${-index * 500}px)`;
			let pre = index === 3 ? 0 : index + 1;
			children[pre].style.transition = '';
			children[pre].style.transform = `translateX(${(-pre + 1) * 500}px)`;
		}
	}

	document.removeEventListener('mousemove', move);
	document.removeEventListener('mouseup', up);
};
</code></pre>
<hr>
<p>上面的代码比较繁琐，其实我们可以将情况简化，我们可以利用 <code>Math.round()</code> 四舍五入求出 <code>mouseup</code> 触发以后要显示的图片（四舍五入后就不需要在特别判断哪个占的面积大了），现在我们要判断的就是另一张图片是前一张还是后一张即可。这个判断也是有规律的，我们利用 <code>Math.abs()</code> 和 <code>Math.sign()</code> 可以得出其值，<code>Math.sign(base)</code> 判断是向左还是向右拖动，<code>Math.abs(base)</code> 判断 <code>base</code> 是否超过一半，结合两者我们就能判断出是上一张还是下一张。代码如下：</p>
<pre><code class="language-javascript">let up = e =&gt; {
	let x = e.clientX - startX;
	
	//index 四舍五入，代码简洁，不易理解，主要是利用四舍五入，统一了要从可视范围移出的元素的下标
	index = (index - Math.round(x / 500)) % children.length;
	index = (index + children.length) % children.length; //四舍五入，得到的就是mouseup触发后应该显示的图片下标
	let base = x % 500;
	for (let offset of [0, (Math.abs(base) &gt; 250 ? 1 : -1) * Math.sign(base)]) {
		let pos = (index + offset + children.length) % children.length; //获得另一个要移动的图片的下标（要移除可视范围的图片）
		children[pos].style.transition = '';
		children[pos].style.transform = `translateX(${(offset - pos) * 500}px)`; //一个下标为index图片要显示它的偏移量是 -index, 偏移量 -1 表示再向左移动一个图片单位，偏移量 1 表示向右移动一个图片单位，最后的总偏移量为 -index + offset
	}

	document.removeEventListener('mousemove', move);
	document.removeEventListener('mouseup', up);
};
</code></pre>
<p>这样代码也简单多了，不过要比上面那个难理解一点。理解的关键就是，同一个方向的移动，<code>base</code> 是否超过一半其 <code>index</code> 是不同的。</p>
<p>完整的代码查看：<a href="https://cdn.clloz.com/study/carousel.html" rel="noreferrer noopener" target="_blank">效果Demo</a></p>
<h3 id="总结">总结</h3>
<p>轮播问题的主要逻辑就是我们不需要关注所有图片，不需要每次移动都要保持视口外的图片都在<strong>正确</strong>的位置，我们只需要关注几张与当前显示相关的图片即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[拖动旋转的 3D 骰子效果]]></title>
        <id>https://clloz.github.io/post/spin-dice1/</id>
        <link href="https://clloz.github.io/post/spin-dice1/">
        </link>
        <updated>2020-09-18T12:09:53.000Z</updated>
        <summary type="html"><![CDATA[<p>本文主要讲解如何用 CSS 实现一个 3D 骰子，以及如何使用 transform 将骰子按自己的需求转动。最后实现用 javascript 实现拖动骰子进行转动的功能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文主要讲解如何用 CSS 实现一个 3D 骰子，以及如何使用 transform 将骰子按自己的需求转动。最后实现用 javascript 实现拖动骰子进行转动的功能。</p>
<!-- more -->
<p id="my-logo"><a href="https://www.clloz.com">Clloz</a></p>
<p>本文首发于个人博客<a href="https://www.clloz.com">clloz.com</a></p>
<h3 id="前言">前言</h3>
<p>用 <code>CSS</code> 实现一个 <code>3d</code> 的骰子，然后实现用鼠标拖动旋转的效果。实现的效果如下，可以拖动这个骰子进行旋转。</p>
<p>查看效果点击：<a href="https://cdn.clloz.com/study/spin-dice/spin-dice.html" rel="noreferrer noopener" target="_blank">效果Demo</a></p>
<h3 id="css-实现-3d-骰子">CSS 实现 3D 骰子</h3>
<p>想要实现一个 <code>3d</code> 的骰子，肯定是要使用 <code>transform</code>。关于 <code>transform</code> 的细节本文就不多讲了，可以参考 <code>MDN</code> 和 <a href="https://www.cnblogs.com/xiaohuochai/p/5351477.html" title="深入理解CSS变形transform(3d)">深入理解CSS变形transform(3d)</a>。我们主要讲讲如何实现效果。</p>
<p><code>HTML</code> 的结构很简单，我们需要一个包含块（最后我们旋转的就是这个包含块），和 <code>6</code> 个子元素作为骰子的六个面。</p>
<pre><code class="language-html">&lt;ul id=&quot;dice&quot;&gt;
	&lt;li class=&quot;front&quot;&gt;1&lt;/li&gt;
	&lt;li class=&quot;back&quot;&gt;2&lt;/li&gt;
	&lt;li class=&quot;right&quot;&gt;3&lt;/li&gt;
	&lt;li class=&quot;left&quot;&gt;4&lt;/li&gt;
	&lt;li class=&quot;top&quot;&gt;5&lt;/li&gt;
	&lt;li class=&quot;bottom&quot;&gt;6&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>父元素的处理非常简单，主要的属性就是 <code>transform-style: preserve-3d</code>，因为我们的子元素是在 <code>3d</code> 空间中的。</p>
<pre><code class="language-css">ul {
	display: block;
	width: 100px;
	height: 100px;
	margin: 100px auto;
	padding: 0;
	list-style: none;
	transform-style: preserve-3d;
}
</code></pre>
<h4 id="六个面的-transform">六个面的 transform</h4>
<p>在处理 <code>transform</code> 之前我们用绝对定位把六个面的元素都固定到父元素的 <code>top left</code> 位置，这样六个面的 <code>transform</code> 的坐标就都相同了。每个面的 <code>transform</code> 都不相同，我们需要在脑海中模拟一下从当前位置到目标位置的移动过程。这里需要注意两点，第一点是坐标轴的方向，<code>z</code> 轴是垂直屏幕向外的的，也就是向外移动是正，向内移动是负，同理 <code>x</code> 轴是左为正，<code>y</code> 轴是下为正；第二点就是元素拥有独立的坐标系，而不是共用同一个坐标自，当一个元素发生了旋转，他的坐标系也在旋转。比如我将一个元素以 <code>x</code> 轴为旋转轴旋转了 <code>180deg</code>，那么此时他的 <code>z</code> 轴就不在是<strong>垂直屏幕向外</strong>，而是<strong>垂直屏幕向内</strong>的，这一点要注意一下。根据这些规则我们来总结一下各个面需要如何移动，我们以骰子的边长为 <code>100px</code> 为例。</p>
<ul>
<li><code>front</code>：沿着 <code>z</code> 轴向外移动 <code>50px</code>。</li>
<li><code>back</code>：沿着 <code>z</code> 轴向内移动 <code>50px</code>。</li>
<li><code>right</code>：以 <code>y</code> 轴为旋转轴顺时针旋转 <code>90deg</code>，然后向右移动 <code>50px</code>。</li>
<li><code>left</code>：以 <code>y</code> 轴为旋转轴逆时针旋转 <code>90deg</code>，然后向左移动 <code>50px</code>。</li>
<li><code>top</code>：以 <code>x</code> 轴为旋转轴顺时针旋转 <code>90deg</code>，然后向上移动 <code>50px</code>。</li>
<li><code>bottom</code>： 以 <code>x</code> 轴为旋转轴逆时针旋转 <code>90deg</code>，然后向下移动 <code>50px</code>。</li>
</ul>
<p>这里的顺时针逆时针我个人总结就是从旋转轴的正方向向负方向看，比如 <code>x</code> 轴是从右往左看，<code>y</code> 轴是从下网上看，如果方向看反的话，顺时针逆时针也会搞反。这里的旋转需要一点空间想象力，特别是刚刚接触 <code>3d</code> 的 <code>transform</code>。</p>
<p>根据上面总结的各个面的移动方式，我们就可以写出我们的代码了。</p>
<pre><code class="language-css">ul li {
	position: absolute;
	display: block;
	width: 100%;
	height: 100%;
	font-size: 30px;
	color: white;
	line-height: 100px;
	text-align: center;
	backface-visibility: visible;
}
.front {
	background-color: rgba(90, 90, 90, 0.7);
	transform: translateZ(50px);
}
.back {
	background-color: rgba(0, 210, 0, 0.7);
	transform: rotateY(180deg) translateZ(50px);
}
.right {
	background-color: rgba(210, 0, 0, 0.7);
	transform: rotateY(90deg) translateZ(50px);
}
.left {
	background-color: rgba(0, 0, 210, 0.7);
	transform: rotateY(-90deg) translateZ(50px);
}
.top {
	background-color: rgba(210, 210, 0, 0.7);
	transform: rotateX(90deg) translateZ(50px);
}
.bottom {
	background-color: rgba(210, 0, 210, 0.7);
	transform: rotateX(-90deg) translateZ(50px);
}
</code></pre>
<p>此时我们就已经得到一个 <code>3d</code> 的骰子了。我们可以给它一个初始的角度或者加上透视，就能够看到 <code>3d</code> 的效果。</p>
<p>查看效果点击：<a href="https://cdn.clloz.com/study/spin-dice/static-spin-dice.html" rel="noreferrer noopener" target="_blank">效果Demo</a></p>
<h4 id="旋转动画">旋转动画</h4>
<p>在实现拖动旋转之前，我们先做一个旋转动画来了解 <code>3d</code> 旋转。我们实现将这个骰子立起来，然后进行旋转，效果如下。</p>
<p>查看效果点击：<a href="https://cdn.clloz.com/study/spin-dice/vertical-spin-dice.html" rel="norenoreferrer noopenerferer" target="_blank">效果Demo</a></p>
<p>如何实现这样的效果呢，我们要做的就是先将筛子立起来。其实就是以 <code>z</code> 轴顺时针旋转 <code>45deg</code>，然后以 <code>x</code> 轴逆时针旋转 <code>45deg</code>。最后的旋转方向我们使用 <code>rotate3d(1, 1, 1, ndeg)</code> 来实现，这里的三个 <code>1</code> 可以理解成向量，我们的旋转轴就是原点到这个向量的连线，原点默认在中心，而 <code>1，1，1</code> 的位置就相当于在 <code>xyz</code> 的坐标系中取点 <code>(1, 1, 1)</code>（这里注意坐标轴的方向和我们平时数学题中的方向不同），他们的连线就是一个垂直穿过的对角的轴。最后的效果就是一个立起来的骰子沿着垂直方向旋转。</p>
<blockquote>
<p><code>safari</code>，<code>firefox</code> 以及 <code>iOS</code> 上的 <code>chrome</code> 都不支持 <code>keyframe</code> 只写两帧（也就是 <code>from - to</code> 和 <code>0% - 100%</code> 的形式）我最终尝试只有 <code>0% 25% 50% 75% 100%</code> 这种形式能正常工作。</p>
</blockquote>
<h3 id="拖动旋转">拖动旋转</h3>
<p>把旋转的原理搞清楚了，实现拖动旋转就非常简单了。我们要做的就是触发 <code>mousemove</code> 的时候就重新计算我们的 <code>transform</code> 的值，这个值的计算就根据 <code>mousedown</code> 时候的 <code>clientX clientY</code> 和 <code>mousemove</code> 时候的 <code>clientX clientY</code> 的差值进行计算，比如移动 <code>10</code> 个像素就转动一度。这里需要注意的一点是，我们鼠标在垂直方向上移动的距离影响的是 <code>rotateX</code> 而不是 <code>rotateY</code>，因为初始方向移动相当于绕着 <code>X</code> 轴旋转。</p>
<p>最后就是当 <code>mouseup</code> 的时候记录当前的 <code>rotateX</code> 和 <code>rotateY</code> 的值，让下次点击事件发生的时候从上次结束的状态开始旋转而不是回到初始状态。最后的代码如下。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
        &lt;title&gt;Spin Dice&lt;/title&gt;
        &lt;style&gt;
            ul {
                display: block;
                width: 100px;
                height: 100px;
                margin: 100px auto;
                padding: 0;
                list-style: none;
                /* perspective: 550px; */
                transform-style: preserve-3d;
                /* transition: all 0.3s ease-in; */
                /* animation: spin 5s infinite linear; */
                transform: rotateX(13deg) rotateY(13deg);
            }
            ul li {
                position: absolute;
                display: block;
                width: 100%;
                height: 100%;
                font-size: 30px;
                color: white;
                line-height: 100px;
                text-align: center;
                backface-visibility: visible;
            }
            .front {
                background-color: rgba(90, 90, 90, 0.7);
                transform: translateZ(50px);
            }
            .back {
                background-color: rgba(0, 210, 0, 0.7);
                transform: rotateY(180deg) translateZ(50px);
            }
            .right {
                background-color: rgba(210, 0, 0, 0.7);
                transform: rotateY(90deg) translateZ(50px);
            }
            .left {
                background-color: rgba(0, 0, 210, 0.7);
                transform: rotateY(-90deg) translateZ(50px);
            }
            .top {
                background-color: rgba(210, 210, 0, 0.7);
                transform: rotateX(90deg) translateZ(50px);
            }
            .bottom {
                background-color: rgba(210, 0, 210, 0.7);
                transform: rotateX(-90deg) translateZ(50px);
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;ul id=&quot;dice&quot;&gt;
            &lt;li class=&quot;front&quot;&gt;1&lt;/li&gt;
            &lt;li class=&quot;back&quot;&gt;2&lt;/li&gt;
            &lt;li class=&quot;right&quot;&gt;3&lt;/li&gt;
            &lt;li class=&quot;left&quot;&gt;4&lt;/li&gt;
            &lt;li class=&quot;top&quot;&gt;5&lt;/li&gt;
            &lt;li class=&quot;bottom&quot;&gt;6&lt;/li&gt;
        &lt;/ul&gt;
        &lt;script&gt;
            let dice = document.getElementById('dice');
            let baseX = 13;
            let baseY = 13;
            dice.addEventListener('mousedown', e =&gt; {
                let rotateX = e.clientX;
                let rotateY = e.clientY;

                let move = e =&gt; {
                    // console.log(baseX, rotateX, e.clientX);
                    // console.log(baseY, rotateY, e.clientY);
                    dice.style.transform = `rotateX(${baseX - (((e.clientY - rotateY) / 10) % 360)}deg) rotateY(${
                        baseY + (((e.clientX - rotateX) / 10) % 360)
                    }deg)`;
                    // console.log(dice.style.transform);
                };
                let up = e =&gt; {
                    baseX = baseX - (((e.clientY - rotateY) / 10) % 360);
                    baseY = baseY + (((e.clientX - rotateX) / 10) % 360);
                    // console.log(baseX, baseY);
                    document.removeEventListener('mousemove', move);
                    document.removeEventListener('mouseup', up);
                };
                document.addEventListener('mousemove', move);
                document.addEventListener('mouseup', up);
            });
            document.addEventListener('selectstart', e =&gt; e.preventDefault());
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>注意要把 <code>CSS</code> 代码中的 <code>transition</code> 注释掉，否则影响旋转效果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[终端设置代理]]></title>
        <id>https://clloz.github.io/post/terminal-proxy-configure/</id>
        <link href="https://clloz.github.io/post/terminal-proxy-configure/">
        </link>
        <updated>2020-09-15T12:27:14.000Z</updated>
        <summary type="html"><![CDATA[<p>大多数非浏览器应用不会主动走代理，本文讲解如何配置终端代理，让git，brew等工具使用更方便。</p>
]]></summary>
        <content type="html"><![CDATA[<p>大多数非浏览器应用不会主动走代理，本文讲解如何配置终端代理，让git，brew等工具使用更方便。</p>
<!-- more -->
<p id="my-logo"><a href="https://www.clloz.com">Clloz</a></p>
<p>本文首发于个人博客<a href="https://www.clloz.com">clloz.com</a></p>
<h3 id="前言">前言</h3>
<p>配置了 <code>V2ray</code> 或者 <code>Shadowsocks</code> 以后，一般来说，只有浏览器（包括内嵌在各种软件中的浏览器，比如 <code>WeGame</code>、优酷、迅雷等软件中的内嵌浏览器）会走代理，其他的应用默认是不走代理的，需要我们手动配置。当需要在终端中使用 <code>brew</code>，<code>git</code> 或者 <code>npm</code> 等安装 <code>package</code> 或应用的时候，如果连接比较吃力的时候启动代理是一个解决方案。本文介绍以下如何在终端中配置代理。</p>
<h3 id="全局代理模式">全局代理模式</h3>
<p>我们使用 <code>V2ray</code> 或者 <code>Shadowsocks</code> 会进行全局代理模式的选择，一般来说有三种 <code>PAC</code>，<code>Global</code> 和 <code>Manual</code>。</p>
<ul>
<li><code>PAC</code>：<code>Proxy auto-config</code>，根据配置文件来确定当前的连接是否需要代理，一般来说这个配置文件是 <code>GFW List</code> 加上我们自己配置的 <code>user rules</code>。关于 <code>user rules</code> 如何配置可以参考我的另一片文章：<a href="https://www.clloz.com/programming/assorted/2019/11/24/v2ray-install-configuration/#user-rules" title="V2ray安装配置教程">V2ray安装配置教程</a></li>
<li><code>Global</code>: 全局模式，所有连接都走代理。</li>
<li><code>Manual</code>：手动模式，不会设置系统级代理，需要使用代理的应用（比如浏览器）都需要手动配置代理。</li>
</ul>
<p>一般来说我们使用前两个模式比较多，大多数情况下 <code>PAC</code> 模式都足够了，如果发现某个我们经常访问的网站不在 <code>PAC</code> 的规则之中，则手动添加到 <code>user rules</code> 里面即可。</p>
<figure data-type="image" tabindex="1"><img src="https://img.clloz.com/blog/writing/proxy-rules.png" alt="proxy-rules" title="proxy-rules" loading="lazy"></figure>
<p>虽然 <code>PAC</code> 和 <code>Global</code> 都设置了系统级代理，但是一般只有浏览器（包括内嵌在各种软件中的浏览器，比如 <code>WeGame</code>、优酷、迅雷等软件中的内嵌浏览器）才会使用这个系统级代理，其他应用一般还是需要手动配置。大部分应用不太需要使用这个需求，但是对于经常使用的终端配置一下代理能让我们使用 <code>homebrew</code>，<code>git</code> 和 <code>npm</code> 下载的时候效率高很多。</p>
<h3 id="终端配置">终端配置</h3>
<p>终端中使用有两种方式，一种是临时配置，重启终端后就失效了；另一种是写入到配置文件中去，每次启动终端都可以使用。我们还需要知道 <code>V2ray</code> 和 <code>Shadowsocks</code> 的客户端给我们提供了三种代理配置类型，<code>HTTP</code>，<code>socks5</code> 和 <code>PAC</code>，对应的端口都不同。</p>
<h4 id="临时配置">临时配置</h4>
<pre><code class="language-bash"># 默认一般address是127.0.0.1，http默认port是1087，socks5默认port是1086，PAC默认port是1089
export http_proxy=http://proxyAddress:port
export https_proxy=&quot;http://localhost:port&quot;
export all_proxy=socks5://127.0.0.1:1086
</code></pre>
<h4 id="写入配置文件">写入配置文件</h4>
<p>在终端配置文件中（<code>.zshrc</code> 或者 <code>.bash_profile</code>）将配置写入。</p>
<pre><code class="language-bash">alias proxy='export all_proxy=socks5://127.0.0.1:1086'
alias unproxy='unset all_proxy'
</code></pre>
<p>使用 <code>proxy</code> 命令开启代理，使用 <code>unproxy</code> 关闭代理。如何检测我们的代理是否开启了，可以使用命令 <code>curl cip.cc</code>，你可以看到你当前的 <code>IP</code>，位置和运营商。如果代理成功开启，那么你可以看到你的 <code>IP</code> 位置等信息都编程了你的代理服务器。</p>
<p>最后还需要注意的一点是，如果你设置了 <code>brew</code> 或者 <code>npm</code> 的国内镜像，那么开启了代理以后，这些镜像的访问也会走代理，可能影响访问速度。</p>
<h3 id="参考文章">参考文章</h3>
<ol>
<li><a href="https://vimcaw.github.io/blog/2018/03/12/Shadowsocks(R)%E8%AE%BE%E7%BD%AE%EF%BC%9A%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%81PAC%E3%80%81%E4%BB%A3%E7%90%86%E8%A7%84%E5%88%99/" title="Shadowsocks(R)设置：系统代理模式、PAC、代理规则">Shadowsocks(R)设置：系统代理模式、PAC、代理规则</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VS Code 的 Snippet 使用教程]]></title>
        <id>https://clloz.github.io/post/vscode-snippet/</id>
        <link href="https://clloz.github.io/post/vscode-snippet/">
        </link>
        <updated>2020-09-14T12:57:39.000Z</updated>
        <summary type="html"><![CDATA[<p>本文讲解如何使用 VS code 的 snippet 功能，为常用开发语言以及配置文件编写自己常用的代码片段，实现简单方便的复用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文讲解如何使用 VS code 的 snippet 功能，为常用开发语言以及配置文件编写自己常用的代码片段，实现简单方便的复用。</p>
<!-- more -->
<p id="my-logo"><a href="https://www.clloz.com">Clloz</a></p>
<p>本文首发于个人博客<a href="https://www.clloz.com">clloz.com</a></p>
<h3 id="前言">前言</h3>
<p>在新建项目的时候，一些配置文件需要重写或者复制都很麻烦。大部分编辑器都提供了 <code>snippet</code> 代码片段功能，<code>VS Code</code> 也提供了很好用的 <code>Snippet</code> 功能，我们不仅可以自定义一些固定的配置，也可以为特定的语言添加我们经常要使用的代码片段。本文讲一下具体如何使用这个功能。</p>
<h3 id="基本结构">基本结构</h3>
<p>其实我们使用的很多插件以及 <code>VS Code</code> 本身就给我们提供了一些 <code>snippet</code>，比如在 <code>HTML</code> 文件中输入 <code>!</code> 然后 <code>tab</code> 就能出现一个基础的 <code>HTML</code> 文档结构。你可以到 <code>VS Code</code> 的 <a href="https://marketplace.visualstudio.com/search?target=vscode&amp;category=Snippets&amp;sortBy=Installs" title="Marketplace">Marketplace</a> 中去找一些别人写好的 <code>snippet</code> 拿来使用。</p>
<p>不过每个人的编码习惯不同，我们会希望根据自己的需求自定义 <code>snippet</code> 来使用，<code>VS Code</code> 也提供了支持。在 <code>Code -&gt; Preferences -&gt; User Snippets</code> 中或者用 ⇧ + ⌘ + P 打开 <code>Command Palette</code> 找到 <code>Preferences: Configure User Snippets</code> 命令即可进行配置。</p>
<figure data-type="image" tabindex="1"><img src="https://img.clloz.com/blog/writing/snippet.png" alt="snippet" title="snippet" loading="lazy"></figure>
<p>从图中可以看到最上面是我们已经定义的 <code>snippet</code>，我们可以选择它们进行修改。后面的选项我们可以选择对应的语言来编写 <code>snippet</code>，这样 <code>snippet</code> 只会在对应的文件格式中生效。我下面主要将自定义的全局 <code>snippet</code> 如何配置，对应语言的 <code>snippet</code> 也是一样的。</p>
<p>我们选择图中的 <code>New Global Snippet File</code> 来定义新的 <code>snippet</code>。每个 <code>snippet</code> 的配置都是使用 <code>json</code> 格式。基本的结构如下：</p>
<pre><code class="language-json">    &quot;snippet name&quot;: {
		&quot;scope&quot;: &quot;language&quot;,
        &quot;prefix&quot;: &quot;shortcut&quot;,
        &quot;body&quot;: [],
        &quot;description&quot;: &quot;output on console&quot;
    },
</code></pre>
<p>各个字段的意义如下：</p>
<ul>
<li><code>scope</code>：在哪些语言中生效，如果没有设置或者值为空则会在所有语言中生效。</li>
<li><code>prefix</code>：前缀，输入前缀即可触发 <code>snippet</code>。我们可以在代码补全的提示框中看到我们设置的 <code>snippet</code>，回车或者 <code>tab</code> 即可输入到文件中。</li>
<li><code>body</code>：代码片段放到这个字段中。注意因为是 <code>json</code>，所以每一行都要用双引号包裹，并且要有逗号。</li>
<li><code>description</code>：<code>snippet</code> 的描述，会在我们输入 <code>prefix</code> 的时候出现在提示框中。</li>
</ul>
<h3 id="参数">参数</h3>
<p>在 <code>snippet</code> 中还支持一些变量和参数。</p>
<ul>
<li><code>TabStops</code> ：<code>$1,$2,$3 ... $0</code>指定代码模块生成后，编辑光标出现位置; 使用 <code>Tab</code> 键进行切换(编辑光标按 <code>$1,$2,$3...$0</code> 的顺序跳转)，<code>$0</code> 是光标最后可切换位置。</li>
<li><code>默认值</code>：可以为光标出现位置添加默认值，<code>${1: placeholder}</code>；也可以有多个默认值 <code>${1|placeholder, placeholder2|}</code>。</li>
<li>变量
<ul>
<li><code>TM_SELECTED_TEXT</code>: 当前选中内容或空字符串</li>
<li><code>TM_CURRENT_LINE</code>: 当前行内容</li>
<li><code>TM_CURRENT_WORD</code>: 光标处字符或空字符串</li>
<li><code>TM_LINE_INDEX</code>: 从0开始的行号</li>
<li><code>TM_LINE_NUMBER</code>: 从1开始的行号</li>
<li><code>TM_FILENAME</code>: 当前被编辑文档名</li>
<li><code>TM_FILENAME_BASE</code>: 当前被编辑文档名，没有后缀</li>
<li><code>TM_DIRECTORY</code>: 当前被编辑文档目录</li>
<li><code>TM_FILEPATH</code>: 当前被编辑文档全路径</li>
<li><code>CLIPBOARD</code>: 当前剪切板内容</li>
<li><code>CURRENT_YEAR</code>: 当前年</li>
<li><code>CURRENT_YEAR_SHORT</code>: 当前年后两位</li>
<li><code>CURRENT_MONTH</code>: 月份，两位数字表示，例如02</li>
<li><code>CURRENT_MONTH_NAME</code>: 月份全称，例如 'July'</li>
<li><code>CURRENT_MONTH_NAME_SHORT</code>: 月份简写 ，例如'Jul</li>
<li><code>CURRENT_DATE</code>: 某天</li>
<li><code>CURRENT_DAY_NAME</code>: 星期几， 例如'Monday'</li>
<li><code>CURRENT_DAY_NAME_SHORT</code>: 星期几的简写， 'Mon'</li>
<li><code>CURRENT_HOUR</code>: 小时，24小时制</li>
<li><code>CURRENT_MINUTE</code>: 分钟</li>
<li><code>CURRENT_SECOND</code>: 秒数</li>
</ul>
</li>
</ul>
<p>我们可以根据自己的需要来选择使用。</p>
<h3 id="删除">删除</h3>
<p><code>VS Code</code> 没有提供快捷删除的方式，我们只能到文件夹中删除。比较好的操作方式是在 <code>VS Code</code> 内置的 <code>teminal</code> 中打开配置文件所在路径进行删除。打开路径的方法可以在 <code>snippet</code> 文件中右键点击 <code>Open in Intergrated Terminal</code> 或者在 <code>Command Palette</code> 中输入指令 <code>File: Copy Path of Active File</code>，然后到命令行中操作。你也可以在左侧的 <code>explorer</code> 中右键文件点击 <code>Reveal in Finder</code> 然后手动删除。</p>
<h3 id="参考文章">参考文章</h3>
<ol>
<li><a href="https://juejin.im/post/6844903912068104199" title="Visual Studio Code (VS Code)自定义代码模板">Visual Studio Code (VS Code)自定义代码模板</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[更换 Apache 到 Nginx]]></title>
        <id>https://clloz.github.io/post/change-apache-to-nginx/</id>
        <link href="https://clloz.github.io/post/change-apache-to-nginx/">
        </link>
        <updated>2020-09-11T13:57:24.000Z</updated>
        <summary type="html"><![CDATA[<p>Apache的内存开销非常大， 对于内存较小的云服务器非常不友好。本文记录将 Web 服务器从 Apache 更换到 nginx 的过程。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Apache的内存开销非常大， 对于内存较小的云服务器非常不友好。本文记录将 Web 服务器从 Apache 更换到 nginx 的过程。</p>
<!-- more -->
<p id="my-logo"><a href="https://www.clloz.com">Clloz</a></p>
<p>本文首发于个人博客<a href="https://www.clloz.com">clloz.com</a></p>
<h3 id="前言">前言</h3>
<p>将服务器上的 <code>Apache</code> 升级到 <code>2.4.46</code> 后，内充占用率飙涨，改了 <code>MaxConnectionPerChild</code> 配置到 <code>50</code> 也不见效。<code>2G</code> 的内存占用率已经超过 <code>90</code>，<code>Apache</code> 吃掉了差不多 <code>1G</code> 内存。<code>systemctl restart httpd</code> 以后，很快又把内存吃回去。虽然一直都遇到内存占用的问题，但之前没有这么严重，也就凑活着用了。每次想换 <code>nginx</code> 都觉得太折腾就作罢。现在这情况只能强行折腾了，服务器都卡的用不了了。下面分享一下更换 <code>web</code> 服务器的过程。</p>
<h3 id="过程">过程</h3>
<p>其实过程也比较简单，停了 <code>apache</code>。</p>
<pre><code class="language-bash">systemctl stop httpd
systemctl disable httpd
</code></pre>
<p>安装 <code>nginx</code>，直接用 <code>yum</code> 安装即可。启动并设置开机启动，同时确保 <code>php-fpm</code> 也启动了。</p>
<pre><code class="language-bash">yum install nginx
systemctl start nginx
systemctl enable ninx
</code></pre>
<p>剩下的就是配置了，配置文件路径 <code>/etc/nginx/nginx.conf</code>。<code>nginx</code> 支持模块化的配置，你可以把不同功能的配置写到不同的文件里面，然后用 <code>include</code> 引入。单独的 <code>conf</code> 文件要放到 <code>/etc/nginx/conf.d</code> 文件夹里。如果你不想创建单独的文件，就把配置写在 <code>nginx.conf</code>文件夹里也可以，是一个 <code>server {}</code>。需要特别注意的是你的配置要写到 <code>include /etc/nginx/conf.d/*.conf</code> 这一句的 <strong>前面</strong>。我一开始就是看错成后面，白白乱折腾了一阵子。</p>
<p>然后 <code>nginx</code> 的配置其实还是比较好理解的，但是不支持 <code>.htaccess</code>。关于配置我这里就不细说了，我也就东拼西凑搞了个差不多的，目前看来基本能用了，有些问题可能后期使用中才能慢慢发现，这里就给大家贴一下我现在的配置。</p>
<pre><code class="language-bash">server {
	#http重定向到https
	listen    80;
	listen [::]:80;
	server_name	www.clloz.com clloz.com;
	return 301	https://$server_name$request_uri;
}
server {
    listen                  443 ssl http2;
    listen                  [::]:443 ssl http2;
    server_name             www.clloz.com clloz.com;

	#网站根目录
    root		    /var/www/html;

	#https
    ssl_certificate         ssl/3793755_www.clloz.com.pem;
    ssl_certificate_key     ssl/3793755_www.clloz.com.key;
    ssl_session_timeout 5m;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。
    ssl_prefer_server_ciphers on;

    # 安全标头
    add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains; preload&quot; always;
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-Xss-Protection 1;

    # 禁用目录列表
    autoindex off;

    # 限制请求次数
    #limit_req_zone $binary_remote_addr zone=WPRATELIMIT:10m rate=2r/s;
    #location ~ \wp-login.php$ {
    #    limit_req zone=WPRATELIMIT;
    #}

    #隐藏 nginx 版本.
    server_tokens off;

    #隐藏 PHP 版本
    fastcgi_hide_header X-Powered-By;
    proxy_hide_header X-Powered-By;

    # 禁止访问敏感文件
    location ~ /\.(svn|git)/* {
        deny all;
    	access_log off;
    	log_not_found off;
    }
    location ~ /\.ht {
    	deny all;
    	access_log off;
    	log_not_found off;
    }
    location ~ /\.user.ini {
    	deny all;
    	access_log off;
    	log_not_found off;
    }

    # 禁止直接访问php文件
#    location ~* /(?:uploads|files|wp-content|wp-includes|akismet)/.*.php$ {
#    	deny all;
#    	access_log off;
#    	log_not_found off;
#    }

	#固定链接交给php-fpm处理
    location / {
		index index.php index.html index.htm;
		try_files $uri $uri/ /index.php?$args;
    }

	# 禁止访问指定类型文件
    location ~ \.(ini|conf)$ {
    	deny all;
    }

    # 允许内部分  wp-includes 目录的 .php 文件
    location ~* ^/wp-includes/.*\.(php|phps)$ {
        internal;
    }

    #禁止访问 wp-config.php install.php 文件
    location = /wp-config.php {
        deny all;
    }
    location = /wp-admin/install.php {
        deny all;
    }


    # 禁止访问 /wp-content/ 目录的 php 格式文件 (包含子目录)
    location ~* ^/wp-content/.*.(php|phps)$ {
        deny all;
    }
    # 固定连接的php处理
    location ~* ^/s/.*.(php|phps)$ {
        #deny all;
	return 404;
    }
    location ~* ^/programming/.*.(php|phps)$ {
        #deny all;
	return 404;
    }
    location ~* ^/essay/.*.(php|phps)$ {
        #deny all;
	return 404;
    }
    location ~* ^/sweets/.*.(php|phps)$ {
        #deny all;
	return 404;
    }
    location ~* ^/links/.*.(php|phps)$ {
        #deny all;
	return 404;
    }
    location ~* ^/abouts/.*.(php|phps)$ {
        #deny all;
	return 404;
    }

    location ~* /(?:uploads|files|wp-content|wp-includes|akismet)/.*.php$ {
    	deny all;
    	access_log off;
    	log_not_found off;
    }

	# 错误页面设置
    error_page 403 /403.html;
    location = /403.html {
        root /etc/nginx/error_pages;
        internal;
    }
    error_page 404 /404.html;
    location = /404.html {
        root /etc/nginx/error_pages;
        internal;
    }
    error_page 500 /500.html;
    location = /500.html {
        root /etc/nginx/error_pages;
        internal;
    }
    error_page 503 /503.html;
    location = /503.html {
        root /etc/nginx/error_pages;
        internal;
    }


    location ~ .php$ {
    	fastcgi_pass   127.0.0.1:9000;
        fastcgi_index  index.php;
    	fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
        include        fastcgi_params;
    }
}
</code></pre>
<p>还有一个没有解决的问题就是，<code>php</code> 类型的 <code>url</code> 都交给 <code>php-fpm</code> 处理，当找不到 <code>url</code> 的时候，<code>php-fpm</code> 会直接返回一个 <code>file not found</code>。我们在 <code>nginx</code> 中设置的 <code>404</code> 页面也不会显示。我本来想看看 <code>php-fpm</code> 能不能设置默认 <code>404</code> 页面的，不过没找到方法。<code>nginx</code> 这边也没设么很好的处理方法，我最后的解决办法就是用 <code>location</code> 来过滤固定链接，只要检测到是固定链接，同时路径是以 <code>php</code> 结束的直接返回 <code>404</code>，固定链接一共也就几种（取决于你有几个一级分类目录）。这个方法有一个瑕疵就是根目录下的以 <code>php</code> 结尾的路径无法过滤，因为根目录下有些 <code>php</code> 是要访问的，我们没法一刀切。不过目前也没有找到其他的好办法，就先这样吧，问题也不大。</p>
<p>**更新：根目录下路径下的 <code>php</code> 结尾的路径我用正则表达式 <code>^/(?!(wp-|xmlrpc))[^/]*php$</code> 进行了处理，把除了 <code>wp-</code> 开头的和 <code>index.php</code>，<code>xmlrpc.php</code> 以外的全部过滤了。除了 <code>wp-content</code>，<code>wp-includes</code>，<code>wp-admin</code> 路径下，其他的带 <code>/</code> 的路径访问 <code>php</code> 都直接返回 <code>404</code>，正则表达式为 <code>^/(?!wp-content|wp-includes|wp-admin|editormd).*/.*php$</code>。</p>
<p>这里顺便说一下 <code>location</code> 配置指令格式为：<code>location [ = | ~ | ~* | ^~ ] uri {...}</code>。这里的 <code>uri</code> 分为标准 <code>uri</code> 和正则 <code>uri</code>，两者的唯一区别是 <code>uri</code> 中是否包含正则表达式。<code>uri</code> 前面的方括号中的内容是可选项，解释如下：</p>
<ul>
<li><code>=</code> ：用于标准 <code>uri</code> 前，要求请求字符串与 <code>uri</code> 严格匹配，一旦匹配成功则停止</li>
<li><code>~</code> ：用于正则 <code>uri</code> 前，并且区分大小写</li>
<li><code>~*</code> ：用于正则 <code>uri</code> 前，但不区分大小写</li>
<li><code>^~</code> ：用于标准 <code>uri</code> 前，要求 <code>Nginx</code> 找到标识 <code>uri</code> 和请求字符串匹配度最高的 <code>location</code> 后，立即使用此 <code>location</code> 处理请求，而不再使用 <code>location</code> 块中的正则 <code>uri</code> 和请求字符串做匹配</li>
</ul>
<p>由于我只是更换 <code>web</code> 服务器，所以还算比较简单，如果你是从头安装，那么你可以看我之前的文章，或者参考腾讯云的这篇教程：<a href="https://cloud.tencent.com/document/product/213/38056" title="手动搭建 LNMP 环境（CentOS 7）">手动搭建 LNMP 环境（CentOS 7）</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 原型机制]]></title>
        <id>https://clloz.github.io/post/javascript-prototype/</id>
        <link href="https://clloz.github.io/post/javascript-prototype/">
        </link>
        <updated>2020-09-11T13:11:59.000Z</updated>
        <summary type="html"><![CDATA[<p>本文用比较简单的语言和图标描述 JavaScript 的原型机制，包括自定义对象之间的原型继承关系以及内置对象的原型继承关系。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文用比较简单的语言和图标描述 JavaScript 的原型机制，包括自定义对象之间的原型继承关系以及内置对象的原型继承关系。</p>
<!-- more -->
<p id="my-logo"><a href="https://www.clloz.com">Clloz</a></p>
<p>本文首发于个人博客<a href="https://www.clloz.com">clloz.com</a></p>
<h3 id="前言">前言</h3>
<p>原型链的概念相信大家都知道，<code>ES6</code> 出来以后可能关注度没有以前那么高的。虽然在 <code>ES2015/ES6</code> 中引入了 <code>class</code> 关键字，但那只是语法糖，<code>JavaScript</code> 仍然是基于原型的，作为 <code>JavaScript</code> 中的主要继承方式，我们有必要深入理解它。理解了原型之后，你对对象的理解也会更深入。</p>
<h3 id="原型机制">原型机制</h3>
<p>原型机制说起来很简单，就是一个对象可以访问它原型对象上的属性和方法，从而实现属性和方法的复用。而原型对象又有自己的原型对象，这样原型就构成了一个链式结构，也就是我们说的原型链。一个对象可以访问自己原型链上的所有方法和属性。</p>
<p><code>JavaScript</code> 中的继承只有一种结构：对象。每个实例对象（ <code>object</code> ）都有一个私有属性（称之为 <code>__proto__</code>，引擎内部是 <code>[[prototype]]</code> ）指向它的构造函数的原型对象（<code>prototype</code> ）。该原型对象也有一个自己的原型对象( <code>__proto__</code> ) ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个原型链中的最后一个环节。</p>
<p>在 <code>JavaScript</code> 中，我们知道的数据类型有 <code>Number, String, Undefined, Null, Boolean, BigInt, Symbol</code> 七个基础类型，还有就是一个引用类型 <code>Object</code>。在内置对象比如 <code>Function, Array, Date, RegExp</code> 等中，<code>Function</code> 是一个特殊的内置对象。</p>
<p>我们将 <code>JavaScript</code> 中的对象分成两大类，一类是 <code>Object</code> ，一类就是 <code>Function</code>。我们来说一下他们之间的关系。</p>
<hr>
<p>我们创建对象有很多种方法，<code>Object.create()</code>，<code>new Object()</code>，<code>new function()</code>，和对象字面量等。但其实他们的本质都是 <code>new Object()</code> （关于 <code>new</code> 和对象创建的内容参考另外两篇文章：<a href="https://www.clloz.com/programming/front-end/js/2020/09/09/javascript-object-prop-assign/" title="JavaScript对象属性类型和赋值细节">JavaScript对象属性类型和赋值细节</a> 和 <a href="https://www.clloz.com/programming/front-end/js/2020/06/29/new-operator/" title="JavaScript中new操作符的解析和实现">JavaScript中new操作符的解析和实现</a>）。</p>
<h4 id="objectprototypeproto">Object.prototype.<strong><strong>proto</strong></strong></h4>
<p>我们用 <code>new Object()</code> 创建一个空对象，它在 <code>Chrome</code> 中打印出的结果如下。</p>
<figure data-type="image" tabindex="1"><img src="https://img.clloz.com/blog/writing/proto1.png" alt="proto3" title="proto1" loading="lazy"></figure>
<p>我们可以看到所谓的 <strong>空对象</strong>，并不是完全空的，它内部有一个 <code>__proto__</code> 属性。但其实这个属性并不是它自身的，这个属性是 <code>Object.prototype.__proto__</code>，一个访问器属性（一个 <code>getter</code> 函数和一个 <code>setter</code> 函数）, 暴露了通过它访问的对象的内部 <code>[[Prototype]]</code> (一个对象或 <code>null</code>)。</p>
<blockquote>
<p>这里要注意，<code>Object.prototype.__proto__</code> 和内部的 <code>[[prototype]]</code> 并不是同一个东西。我们的原型是靠内部的 <code>[[prototype]]</code> 链接的，<code>Object.prototype.__proto__</code> 只是浏览器提供的一个访问器属性向我们暴露 <code>[[prototype]]</code>。</p>
</blockquote>
<p>这个属性是由浏览器厂商提供的，并且目前绝大多数的浏览器都支持这个属性，所以 <code>ECMAScript 2015</code> 中也将其写入标准附录中，保持浏览器的兼容性。但是直接修改对象的 <code>[[prototype]]</code> 在任何引擎和浏览器中都是非常慢并且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，并且性能消耗的时间也不是简单的花费在 <code>obj.__proto__ = ...</code> 语句上, 它还会影响到所有继承来自该 <code>[[Prototype]]</code> 的对象。标准中还提供了两组关于读写原型对象的方法 <code>Object.getPrototypeOf/Reflect.getPrototypeOf</code> 和 <code>Object.setPrototypeOf/Reflect.setPrototypeOf</code>。不过写对象和上面说的一样，依然是一个影响性能的操作，如果你关心性能，不应该用这些方法。比较好的实践是用 <code>Object.create()</code> 来设置原型，用 <code>Object.getPrototypeOf()</code> 来读取原型对象。</p>
<blockquote>
<p>我们同样可以用对象字面量来设置 <code>__proto__</code>，也可以自定义 <code>__proto__</code> 来覆盖 <code>Object.prototype.__proto__</code>。参考文章：<a href="https://www.clloz.com/programming/front-end/js/2020/09/09/javascript-object-prop-assign/" title="JavaScript对象属性类型和赋值细节">JavaScript对象属性类型和赋值细节</a>。</p>
</blockquote>
<p>不同类型的对象其 <code>[[prototype]]</code> 是不同的，对于使用数组字面量创建的对象，这个值是 <code>Array.prototype</code>。对于 <code>functions</code>，这个值是 <code>Function.prototype</code>。对于使用 <code>new fun</code> 创建的对象，其中 <code>fun</code> 是由 <code>js</code> 提供的内建构造器函数之一(<code>Array, Boolean, Date, Number, Object, String</code> 等等），这个值总是 <code>fun.prototype</code>。对于用 <code>js</code> 定义的其他 <code>js</code> 构造器函数创建的对象，这个值就是该构造器函数的 <code>prototype</code> 属性。关于内置对象之间的关系，我们后面会详细讨论。</p>
<h4 id="object-和-function">Object 和 Function</h4>
<p><code>Object</code> 和 <code>Function</code> 是 <code>JavaScript</code> 中最重要的两个对象，他们同时也是构造函数 <code>function Object(), function Function()</code>。几乎所有对象都是 <code>function Object()</code> 的实例，而所有函数都是 <code>function Function()</code> 的实例，包括 <code>Object</code> 也是由 <code>Function</code> 构造的。</p>
<p>我们上面说过对象内部有一个 <code>[[prototype]]</code> 属性指向它的源性对象；而每一个函数都有一个 <code>prototype</code> 属性，指向由这个函数构造出的对象的 <code>[[prototype]]</code>。更准确的说，在函数被创建的时候，就有一个 <code>prototype</code> 属性指向一个对象，这个对象本身只有一个 <code>constructor</code> 属性指向这个函数。当用 <code>new func()</code> 创建对象的时候，新对象的 <code>[[prototype]]</code> 就指向构造函数的 <code>prototype</code> 对应的对象。不过需要注意的是 <code>prototype</code> 和 <code>constructor</code> 都是可以 <strong>重写</strong> 的。</p>
<figure data-type="image" tabindex="2"><img src="https://img.clloz.com/blog/writing/proto2.png" alt="proto3" title="proto2" loading="lazy"></figure>
<p>对于我们的自定义对象，这是很好理解的。那么内置对象之间的关系，特别是 <code>Object</code> 和 <code>Function</code> 之间的关系是怎么样的呢。先明确两点：</p>
<ol>
<li>一切函数都是由 <code>function Function()</code> 构造的，所以函数的 <code>[[prototype]]</code> 指向 <code>Function.prototype</code>。</li>
<li>所有由 <code>function Object()</code> 构造的非函数对象的 <code>[[prototype]]</code> 指向 <code>Object.prototype</code>。</li>
<li>函数的创建的同时，会创建一个 <code>function.prototype</code> 对象，该对象是一个由 <code>function Object()</code> 构造的对象。<code>prototype</code> 属性可以任意指定，指定的对象内可能没有 <code>constructor</code> 属性或者是错误的 <code>constructor</code>。</li>
<li>所有非函数对象都是由构造函数通过 <code>new</code> 运算符创建的（本质都是 <code>new Object()</code>，很多内置对象可以省略 <code>new</code>，比如 <code>Function</code>， <code>Object</code>，<code>Array</code>，省略和不省略效果是一样的)。这个构造函数要么是自定义的（由 <code>function Function()</code> 构造），要么是 <code>function Object()</code>。</li>
<li>自定义函数手动指定 <code>prototype</code> 为其它自定函数的实例， 可以让我们实现链式继承，这条链最终有一个节点会是有 <code>function Object()</code> 构造的对象，它的 <code>[[protottype]]</code> 指向 <code>Object.prototype</code>。所以我们可以说，所有的非函数对象都是 <code>function Object()</code> 的实例。</li>
</ol>
<p>其实记住这几点就可以应对绝大部分问题，如果你还对内置对象的关系有兴趣，可以继续往下看。</p>
<hr>
<p>根据我们上面的两条规律我们可以知道 <code>Object</code> 的 <code>[[prototype]]</code> 指向 <code>Function.prototype</code>，那么 <code>function Function()</code> ，<code>Function.prototype</code> 和 <code>Object.prototype</code> 的 <code>[[prototype]]</code> 都分别是什么呢？</p>
<p>先说 <code>Object.prototype</code>，它是所有非函数对象的 <code>[[prototype]]</code> 指向，而它自己的 <code>[[prototype]]</code> 指向的就是 <code>null</code>，也就是一切对象的原型链的终点。它的 <code>constructor</code> 属性指向 <code>function Object()</code></p>
<p>而 <code>function Function()</code> 的 <code>[[prototype]]</code> 和其它的函数一样，指向 <code>Function.prototype</code>，也就是说 <code>function Function()</code> 的 <code>prototype</code> 和 <code>[[prototype]]</code>指向的是同一个对象 <code>Function.prototype</code>。</p>
<p><code>Function.prototype</code> 的 <code>[[prototype]]</code> 指向的是 <code>Object.prototype</code>。<code>consctructor</code> 指向的是 <code>function Function()</code>。其实 <code>Function.prototype</code> 本身就是函数，可以直接调用，接受任何参数并返回 <code>undefined</code>。</p>
<p>为什么要这样呢？我认为是确保每一个函数对象，非函数对象，他们的原型链上都有 <code>Object.prototype</code>，都能够访问 <code>Object.prototype</code> 上定义的一些公有方法。</p>
<pre><code class="language-javascript">constructor: ƒ Object()
hasOwnProperty: ƒ hasOwnProperty()
isPrototypeOf: ƒ isPrototypeOf()
propertyIsEnumerable: ƒ propertyIsEnumerable()
toLocaleString: ƒ toLocaleString()
toString: ƒ toString()
valueOf: ƒ valueOf()
__defineGetter__: ƒ __defineGetter__()
__defineSetter__: ƒ __defineSetter__()
__lookupGetter__: ƒ __lookupGetter__()
__lookupSetter__: ƒ __lookupSetter__()
get __proto__: ƒ __proto__()
set __proto__: ƒ __proto__()
</code></pre>
<p>想要更清晰的看清楚我上面说的关系，可以借助于这张来自网上的图，画的非常好。</p>
<figure data-type="image" tabindex="3"><img src="https://img.clloz.com/blog/writing/proto3.jpg" alt="proto3" title="proto3" loading="lazy"></figure>
<h4 id="其他内置对象">其他内置对象</h4>
<p>最后在说一说其他的内置对象，绝大多数内置对象都是函数对象（<code>BigInt</code>，<code>Math</code>，<code>JSON</code> 和 <code>Reflect</code> 不是函数对象），虽然有些不能用 <code>new</code> 操作符（比如 <code>Symbol</code>，有些对象用不用 <code>new</code> 表现一样，比如 <code>Object</code>， <code>Function</code>，<code>Array</code> 等）。所以内置对象的 <code>[[prototype]]</code> 指向 <code>function.prototype</code>。内置对象的 <code>prototype</code> 一般来说就是一个普通的对象（用 <code>function Object()</code> 构造的）。这个对象上挂载了很多该类型可以使用的方法，比如 <code>Array.prototype</code> 有如下属性：</p>
<pre><code class="language-javascript">concat: ƒ concat()
constructor: ƒ Array()
copyWithin: ƒ copyWithin()
entries: ƒ entries()
every: ƒ every()
fill: ƒ fill()
filter: ƒ filter()
find: ƒ find()
findIndex: ƒ findIndex()
flat: ƒ flat()
flatMap: ƒ flatMap()
forEach: ƒ forEach()
includes: ƒ includes()
indexOf: ƒ indexOf()
join: ƒ join()
keys: ƒ keys()
lastIndexOf: ƒ lastIndexOf()
length: 0
map: ƒ map()
pop: ƒ pop()
push: ƒ push()
reduce: ƒ reduce()
reduceRight: ƒ reduceRight()
reverse: ƒ reverse()
shift: ƒ shift()
slice: ƒ slice()
some: ƒ some()
sort: ƒ sort()
splice: ƒ splice()
toLocaleString: ƒ toLocaleString()
toString: ƒ toString()
unshift: ƒ unshift()
values: ƒ values()
Symbol(Symbol.iterator): ƒ values()
Symbol(Symbol.unscopables): {copyWithin: true, entries: true, fill: true, find: true, findIndex: true, …}
__proto__: Object
</code></pre>
<p>需要注意的一点是，几乎所有内置对象的属性都是不可枚举的，所以无论是 <code>for ... in</code> 还是 <code>Object.keys()</code> 都是无法枚举这些属性的。我们自己也可以在内置对象的 <code>prototype</code> 上添加属性或者方法，让所有该类型的对象都能使用。</p>
<p>基本包装类型 <code>String</code>，<code>Number</code> 和 <code>Boolean</code> 在一般情况下不要使用创建对象的方式来初始化对应的类型。使用这种方式创建的值都是对象（使用 <code>typeof</code> 返回 <code>object</code>），而且所有基本包装类型的对象都会被转换为布尔值 <code>true</code>。看下面的代码。</p>
<pre><code class="language-javascript">console.log(typeof String('')) //string
console.log(typeof new String('')) //object
console.log(!!'') //false
console.log(!!String('')) //false
console.log(!!new String('')) //true

console.log(typeof Number(0)) //number
console.log(typeof new Number(0)) //object
console.log(!!0) //false
console.log(!!Number(0)) //false
console.log(!!new Number(0)) //true

console.log(typeof Boolean('')) //string
console.log(typeof new Boolean('')) //object
console.log(!!Boolean('')) //false
console.log(!!new Boolean('')) //true
</code></pre>
<p>关于 <code>constructor</code> 和 <code>prototype</code> 有一个有趣的小题目，可以看一看：<a href="https://www.clloz.com/programming/front-end/js/2019/05/31/prototype-constructor/" title="关于constructor和prototype的思考">关于constructor和prototype的思考</a></p>
<h3 id="参考文章">参考文章</h3>
<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" title="继承与原型链">继承与原型链 - MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" title="Object.prototype.__proto__ - MDN">Object.prototype.<strong>proto</strong> - MDN</a></li>
</ol>
]]></content>
    </entry>
</feed>